#+title: Configurations for GNU Emacs
#+author: takeounn
#+email: bararararatty@gmail.com
#+startup: content
#+startup: nohideblocks
#+options: num:t auto-id:t
#+setupfile: theme-readtheorg.setup
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* はじめに
** 基本情報
  - repo: [[http://github.com/takeokunn/.emacs.d][takeokunn/.emacs.d]]
  - twitter: [[https://twitter.com/takeokunn][たけてぃ@takeokunn]]
* Initialize
** leaf
   #+BEGIN_SRC emacs-lisp
     (eval-and-compile
       (when (or load-file-name byte-compile-current-file)
         (setq user-emacs-directory
               (expand-file-name
                (file-name-directory (or load-file-name byte-compile-current-file))))))

     (eval-and-compile
       (customize-set-variable
        'package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                            ("melpa" . "https://melpa.org/packages/")
                            ("org" . "https://orgmode.org/elpa/")))
       (package-initialize)
       (unless (package-installed-p 'leaf)
         (package-refresh-contents)
         (package-install 'leaf))

       (leaf leaf-keywords
         :ensure t
         :init
         ;; optional packages if you want to use :hydra, :el-get, :blackout,,,
         ;; (leaf hydra :ensure t)
         (leaf el-get :ensure t)
         ;; (leaf blackout :ensure t)

         :config
         ;; initialize leaf-keywords.el
         (leaf-keywords-init)))
   #+END_SRC
** utility
   #+BEGIN_SRC emacs-lisp
     (leaf dash :ensure t)
     (leaf dash-functional :ensure t)
     (leaf s :ensure t)
     (leaf f :ensure t)
     (leaf ht :ensure t)
     (leaf general :ensure t)
   #+END_SRC
* Basic
** early-init
   #+BEGIN_SRC emacs-lisp
     (if (version< emacs-version "27")
         (progn
           (menu-bar-mode -1)
           (tool-bar-mode -1)
           (toggle-scroll-bar -1)))
   #+END_SRC
** スタートアップメッセージを非表示
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC
** 末尾のスペースを可視化する
   特定のmode以外末尾のスペースを可視化するようにした。
   #+BEGIN_SRC emacs-lisp
     (setq-default show-trailing-whitespace t)

     (dolist
         (mode '(comint-mode
                 eshell-mode
                 eww-mode
                 term-mode
                 twittering-mode
                 minibuffer-inactive-mode))
       (add-hook (intern (concat (symbol-name mode) "-hook"))
                 '(lambda () (setq show-trailing-whitespace nil))))
   #+END_SRC
** 行番号を表示する
   #+BEGIN_SRC emacs-lisp
     (global-linum-mode t)
   #+END_SRC
** 自動生成ファイルを無効にする
   #+BEGIN_SRC emacs-lisp
     (setq make-backup-files nil)
     (setq auto-save-default nil)
     (setq auto-save-list-file-prefix nil)
     (setq create-lockfiles nil)
   #+END_SRC
** C-kで行削除
   #+BEGIN_SRC emacs-lisp
     (setq kill-whole-line t)
   #+END_SRC
** カッコの中をハイライトする
   #+BEGIN_SRC emacs-lisp
     (show-paren-mode t)
     (setq-default show-paren-style 'mixed)
   #+END_SRC
** カッコが自動的に作られるようにする
   #+BEGIN_SRC emacs-lisp
     (electric-pair-mode 1)
   #+END_SRC
** time locale
   #+BEGIN_SRC emacs-lisp
     (setq system-time-locale "C")
   #+END_SRC
** Font
   #+BEGIN_SRC emacs-lisp
     (set-fontset-font t 'japanese-jisx0208 "TakaoPGothic")
     (add-to-list 'face-font-rescale-alist '(".*Takao P.*" . 0.85))
   #+END_SRC
** GC
   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold (* 128 1024 1024)) ;; 128MB
     (setq garbage-collection-messages t)
   #+END_SRC
** indent
   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC
** keybind
   #+BEGIN_SRC emacs-lisp
     (keyboard-translate ?\C-h ?\C-?)

     (general-define-key
      "M-¥" (lambda () (interactive) (insert "\\"))
      "C-h" 'backward-delete-char
      "C-z" 'undo
      "C-?" 'help-command
      "C-m" 'set-mark-command
      "C-a" 'back-to-indentation
      "C-c i" 'find-function
      "C-x C-o" 'other-window
      "C-x C-k" nil)
   #+END_SRC
** ビープ音を消す
   #+begin_src emacs-lisp
     (setq ring-bell-function 'ignore)
   #+end_src
* Major/Minor Mode
** clojure-mode
   #+BEGIN_SRC emacs-lisp
     (leaf clojure-mode
       :ensure t
       :mode ("\\.clj$" "\\.cljs$"))
   #+END_SRC
** cmake-mode
   #+BEGIN_SRC emacs-lisp
     (leaf cmake-mode
       :ensure t
       :mode ("\\.cmake$"))
   #+END_SRC
** coffee-mode
   #+BEGIN_SRC emacs-lisp
     (leaf coffee-mode
       :ensure t
       :mode ("\\.coffee$"))
   #+END_SRC
** csharp-mode
   #+BEGIN_SRC emacs-lisp
     (leaf csharp-mode
       :ensure t
       :mode ("\\.cs$"))
   #+END_SRC
** csv-mode
   #+BEGIN_SRC emacs-lisp
     (leaf csv-mode :ensure t)
   #+END_SRC
** dhall-mode
   #+BEGIN_SRC emacs-lisp
     (leaf dhall-mode
       :ensure t
       :mode ("\\dhall$"))
   #+END_SRC
** docker-compose-mode
   #+begin_src emacs-lisp
     (leaf docker-compose-mode
       :ensure t
       :mode ("docker-compose*"))
   #+end_src
** dockerfile-mode
   #+BEGIN_SRC emacs-lisp
     (leaf dockerfile-mode
       :ensure t
       :mode ("Dockerfile\\'"))
   #+END_SRC
** emacs-lisp-mode
   #+BEGIN_SRC emacs-lisp
     ;; (leaf emacs-lisp-mode
     ;;   :mode ("\\.skk$"))
   #+END_SRC
** emmet-mode
   #+BEGIN_SRC emacs-lisp
     (leaf emmet-mode
       :ensure t
       :after web-mode
       :bind (("C-j" . nil))
       :hook (web-mode-hook))
   #+END_SRC
** fish-mode
   #+BEGIN_SRC emacs-lisp
     (leaf fish-mode
       :ensure t
       :mode ("\\.fish$"))
   #+END_SRC
** gitignore-mode
   #+BEGIN_SRC emacs-lisp
     (leaf gitignore-mode
       :ensure t
       :mode ("\\.dockerignore$"))
   #+END_SRC
** glsl-mode
   #+BEGIN_SRC emacs-lisp
     (leaf glsl-mode
       :ensure t
       :mode ("\\.vsh$" "\\.fsh$"))
   #+END_SRC
** go-mode
   #+BEGIN_SRC emacs-lisp
     (leaf go-mode
       :ensure t
       :mode ("\\.go$"))
   #+END_SRC
** gradle-mode
   #+BEGIN_SRC emacs-lisp
     (leaf gradle-mode
     :ensure t
       :mode (("\\.gradle$" . java-mode)))
   #+END_SRC
** haskell-mode
   #+BEGIN_SRC emacs-lisp
     (leaf haskell-mode
       :ensure t
       :mode ("\\.hs$" "\\.cable$"))
   #+END_SRC
** js2-mode
   #+BEGIN_SRC emacs-lisp
     (leaf js2-mode
       :ensure t
       :mode ("\\.js$")
       :hook ((js2-mode-hook . js2-refactor-mode)
              (js2-mode-hook . lsp-mode)))
   #+END_SRC
** json-mode
   #+BEGIN_SRC emacs-lisp
     (leaf json-mode
       :ensure t
       :mode ("\\.json$"))
   #+END_SRC
** lisp-mode
   #+BEGIN_SRC emacs-lisp
     (leaf lisp-mode
       :mode ("Cask" "\\.lemrc?$"))
   #+END_SRC
** markdown-mode
   #+BEGIN_SRC emacs-lisp
     (leaf markdown-mode
       :ensure t
       :mode ("\\.md$" "\\.markdown$"))
   #+END_SRC
** nginx-mode
   #+BEGIN_SRC emacs-lisp
     (leaf nginx-mode
       :ensure t
       :mode ("/nginx/sites-\\(?:available\\|enabled\\)/"))
   #+END_SRC
** php-mode
   #+BEGIN_SRC emacs-lisp
     (leaf php-mode
       :ensure t
       :mode ("\\.php$"))
   #+END_SRC
** plantuml-mode
   #+BEGIN_SRC emacs-lisp
     (leaf plantuml-mode
       :ensure t
       :mode ("\\.pu$"))
   #+END_SRC
** processing-mode
   #+BEGIN_SRC emacs-lisp
     (leaf processing-mode
       :ensure t
       :mode ("\\.pde$")
       :config
       (with-eval-after-load 'processing-mode
         (setq-default processing-location "/opt/processing/processing-java")
         (setq-default processing-output-dir "/tmp")))
  #+END_SRC
** python-mode
   #+BEGIN_SRC emacs-lisp
     (leaf python-mode
       :ensure t
       :mode ("\\.py$")
       :interpreter ("python"))
   #+END_SRC
** ruby-mode
   #+BEGIN_SRC emacs-lisp
     (leaf ruby-mode
       :ensure t
       :mode ("\\.rb$" "Capfile" "Gemfile" "Schemafile" ".pryrc")
       :config
       (with-eval-after-load 'ruby-mode
         (setq-default ruby-insert-encoding-magic-comment nil)))
   #+END_SRC
** rust-mode
   #+BEGIN_SRC emacs-lisp
     (leaf rust-mode
       :ensure t
       :mode ("\\.rs$"))
   #+END_SRC
** scala-mode
   #+BEGIN_SRC emacs-lisp
     (leaf scala-mode
       :ensure t
       :mode ("\\.scala$"))
   #+END_SRC
** scheme-mode
   #+BEGIN_SRC emacs-lisp
     ;; (setq-default gosh-program-name "/usr/local/bin/gosh -i")

     ;; (general-def inferior-scheme-mode-map
     ;;   "C-p" 'comint-previous-input
     ;;   "C-n" 'comint-next-input)
   #+END_SRC
** slim-mode
   #+BEGIN_SRC emacs-lisp
     (leaf slim-mode
       :ensure t
       :mode ("\\.slim$"))
   #+END_SRC
** ssh-config-mode
   #+BEGIN_SRC emacs-lisp
     (leaf ssh-config-mode
       :ensure t
       :mode ("/path-to-your-ssh/config\\$"))
   #+END_SRC
** terraform-mode
   #+BEGIN_SRC emacs-lisp
     (leaf terraform-mode
       :ensure t
       :mode ("\\.tf$"))
   #+END_SRC
** toml-mode
   #+BEGIN_SRC emacs-lisp
     (leaf toml-mode
       :ensure t
       :mode ("\\.toml$"))
   #+END_SRC
** typescript-mode
   #+BEGIN_SRC emacs-lisp
     (leaf typescript-mode
       :ensure t
       :mode ("\\.ts$"))
   #+END_SRC
** vue-mode
   #+BEGIN_SRC emacs-lisp
     (leaf vue-mode
       :ensure t
       :mode ("\\.vue$"))
   #+END_SRC
** vimrc-mode
   #+begin_src emacs-lisp
     (leaf vimrc-mode
       :ensure t
       :mode ("\\.vim\\(rc\\)?\\'"))
   #+end_src
** web-mode
   #+BEGIN_SRC emacs-lisp
     (leaf web-mode
       :ensure t
       :mode ("\\.html?\\'" "\\.erb\\'" "\\.gsp\\'" "\\.tsx\\'"))
   #+END_SRC
** yaml-mode
   #+BEGIN_SRC emacs-lisp
     (leaf yaml-mode
       :ensure t
       :mode ("\\.ya?ml$"))
   #+END_SRC
* Lisp
** Basic
*** paredit
    #+BEGIN_SRC emacs-lisp
      (leaf paredit
        :ensure t
        :commands enable-paredit-mode
        :hook ((emacs-lisp-mode-hook . enable-paredit-mode)
               (lisp-mode-hook . enable-paredit-mode)
               (lisp-interacton-mode-hook . enable-paredit-mode)
               (scheme-mode-hook . enable-paredit-mode))
        :bind
        ("C-<right>" . paredit-forward-slurp-sexp)
        ("C-c f" . paredit-forward-slurp-sexp)
        ("C-<left>" . paredit-forward-barf-sexp)
        ("C-c b" . paredit-forward-barf-sexp))
    #+END_SRC
*** rainbow-delimiters
    #+BEGIN_SRC emacs-lisp
      (leaf rainbow-delimiters
        :ensure t
        :hook (prog-mode-hook))
    #+END_SRC
** CommonLisp
*** TODO HyperSpec
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'hyperspec
        (general-define-key "C-c h" 'hyperspec-lookup)

        (setq common-lisp-hyperspec-root "~/.roswell/HyperSpec/")

        (defun common-lisp-hyperspec (symbol-name)
          (interactive (list (common-lisp-hyperspec-read-symbol-name)))
          (let ((name (common-lisp-hyperspec--strip-cl-package
                       (downcase symbol-name))))
            (cl-maplist (lambda (entry)
                          (eww-open-file (concat common-lisp-hyperspec-root "Body/"
                                                 (car entry)))
                          (when (cdr entry)
                            (sleep-for 1.5)))
                        (or (common-lisp-hyperspec--find name)
                            (error "The symbol `%s' is not defined in Common Lisp"
                                   symbol-name)))))

        (defun common-lisp-hyperspec-lookup-reader-macro (macro)
          (interactive
           (list
            (let ((completion-ignore-case t))
              (completing-read "Look up reader-macro: "
                               common-lisp-hyperspec--reader-macros nil t
                               (common-lisp-hyperspec-reader-macro-at-point)))))
          (eww-open-file
           (concat common-lisp-hyperspec-root "Body/"
                   (gethash macro common-lisp-hyperspec--reader-macros))))

        (defun common-lisp-hyperspec-format (character-name)
          (interactive (list (common-lisp-hyperspec--read-format-character)))
          (cl-maplist (lambda (entry)
                        (eww-open-file (common-lisp-hyperspec-section (car entry))))
                      (or (gethash character-name
                                   common-lisp-hyperspec--format-characters)
                          (error "The symbol `%s' is not defined in Common Lisp"
                                 character-name))))

        (defadvice common-lisp-hyperspec (around common-lisp-hyperspec-around activate)
          (let ((buf (current-buffer)))
            ad-do-it
            (switch-to-buffer buf)
            (pop-to-buffer "*eww*")))

        (defadvice common-lisp-hyperspec-lookup-reader-macro (around common-lisp-hyperspec-lookup-reader-macro-around activate)
          (let ((buf (current-buffer)))
            ad-do-it
            (switch-to-buffer buf)
            (pop-to-buffer "*eww*")))

        (defadvice common-lisp-hyperspec-format (around common-lisp-hyperspec-format activate)
          (let ((buf (current-buffer)))
            ad-do-it
            (switch-to-buffer buf)
            (pop-to-buffer "*eww*"))))
    #+END_SRC
*** slime
    #+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'slime
        (load (expand-file-name "~/.roswell/helper.el"))
        (add-hook 'slime-mode-hook 'set-up-slime-ac)
        (add-hook 'slime-repl-mode-hook 'set-up-slime-ac))
    #+END_SRC
*** takeokunn/slime-history
    #+BEGIN_SRC emacs-lisp
      (defun takeokunn/slime-history ()
        (interactive)
        (insert
         (completing-read
          "choice history: "
          (-distinct (read (f-read-text "~/.slime-history.eld"))))))

      (general-define-key
       :keymaps 'slime-repl-mode-map
       "C-c C-r" 'takeokunn/slime-history)
    #+END_SRC
** EmacsLisp
*** elisp-slime-nav
    #+BEGIN_SRC emacs-lisp
      (leaf elisp-slime-nav :ensure t)
    #+END_SRC
*** nameless
    #+BEGIN_SRC emacs-lisp
      (leaf nameless
        :ensure t
        :hook (emacs-lisp-mode-hook))
    #+END_SRC
*** TODO takeokunn/ielm-history
    #+BEGIN_SRC emacs-lisp
      (defun takeokunn/ielm-history ()
        (interactive)
        (insert
         (completing-read
          "choice history: "
          (progn
            (let ((history nil))
              (dotimes (index (ring-length comint-input-ring))
                (push (ring-ref comint-input-ring index) history))
              history)))))

      (defun takeokunn/ielm-write-history-on-exit (process event)
        (comint-write-input-ring)
        (let ((buf (process-buffer process)))
          (when (buffer-live-p buf)
            (with-current-buffer buf
              (insert (format "\nProcess %s %s" process event))))))

      (defun takeokunn/ielm-turn-on-history ()
        (let ((process (get-buffer-process (current-buffer))))
          (when process
            (setq comint-input-ring-file-name (concat (file-remote-p default-directory) "~/.ielm-history"))
            (setq comint-input-ring-size 100000)
            (setq comint-input-ignoredups t)
            (comint-read-input-ring)
            (add-hook 'kill-buffer-hook #'comint-write-input-ring)
            (general-define-key
             :keymaps 'ielm-map
             "C-c C-r" 'takeokunn/ielm-history)

            (set-process-sentinel process #'takeokunn/ielm-write-history-on-exit))))

      (add-hook 'ielm-mode-hook 'takeokunn/ielm-turn-on-history)
    #+END_SRC
** Clojure
*** cider
    #+BEGIN_SRC emacs-lisp
      (leaf cider
        :ensure t)
    #+END_SRC
* Awesome Package
** Theme
*** all-the-icons
    #+BEGIN_SRC emacs-lisp
      (leaf all-the-icons
        :ensure t
        ;; :hook ((dired-mode-hook . all-the-icons-dired-mode))
        )
    #+END_SRC
*** all-the-icons-ivy
    #+BEGIN_SRC emacs-lisp
      (leaf all-the-icons-ivy
        :ensure t
        :after all-the-icons
        :config
        (all-the-icons-ivy-setup))
    #+END_SRC
*** doom-modeline
    #+BEGIN_SRC emacs-lisp
      (leaf doom-modeline
        :ensure t
        :hook (after-init-hook)
        :custom ((doom-modeline-buffer-file-name-style quote truncate-with-project)
                 (doom-modeline-icon . t)
                 (doom-modeline-major-mode-icon)
                 (doom-modeline-minor-modes))
        :config
        (with-eval-after-load 'doom-modeline
          (line-number-mode 0)
          (column-number-mode 0)))
    #+END_SRC
*** doom-theme
    #+BEGIN_SRC emacs-lisp
      (leaf doom-themes
        :ensure t
        :after neotree
        :custom-face ((doom-modeline-bar quote
                                         ((t
                                           (:background "#6272a4")))))
        :config
        (load-theme 'tango-dark t)
        (doom-themes-neotree-config)
        (doom-themes-org-config))
   #+END_SRC
*** hl-line
    #+BEGIN_SRC emacs-lisp
      (leaf hl-line
        :ensure t
        :init
        (global-hl-line-mode)
        :config
        (set-face-background 'hl-line "#444642")
        (set-face-attribute 'hl-line nil :inherit nil))
    #+END_SRC
*** hl-todo
    #+BEGIN_SRC emacs-lisp
      (leaf hl-todo
        :ensure t
        :init
        (global-hl-todo-mode 1)
        :custom ((hl-todo-keyword-faces '(("HOLD" . "#d0bf8f")
                                        ("WAIT" . "#d0bf8f")
                                        ("TODO" . "#cc9393")
                                        ("NEXT" . "#dca3a3")
                                        ("THEM" . "#dc8cc3")
                                        ("REMIND" . "#dc8cc3")
                                        ("PROG" . "#7cb8bb")
                                        ("OKAY" . "#7cb8bb")
                                        ("DONT" . "#5f7f5f")
                                        ("FAIL" . "#8c5353")
                                        ("SOMEDAY" . "#8c5353")
                                        ("DONE" . "#afd8af")
                                        ("FIXME" . "#cc9393")
                                        ("???" . "#cc9393")))))
    #+END_SRC
*** neotree
    #+BEGIN_SRC emacs-lisp
      (leaf neotree
        :ensure t
        :preface
        (defun takeokunn/neotree-toggle ()
          (interactive)
          (let ((default-directory (locate-dominating-file default-directory ".git")))
            (neotree-toggle)))
        (defun neo-buffer--insert-fold-symbol (name &optional file-name)
          (or
           (and
            (equal name 'open)
            (insert
             (all-the-icons-icon-for-dir file-name "down")))
           (and
            (equal name 'close)
            (insert
             (all-the-icons-icon-for-dir file-name "right")))
           (and
            (equal name 'leaf)
            (insert
             (format "			%s	"
                     (all-the-icons-icon-for-file file-name))))))

        :after all-the-icons
        :custom ((neo-theme quote nerd2))
        :setq-default ((neo-show-hidden-files . t)
                       (neo-window-fixed-size))
        :bind ("C-q" . takeokunn/neotree-toggle))
    #+END_SRC
*** nyan-mode
    #+BEGIN_SRC emacs-lisp
      (leaf nyan-mode
        :ensure t
        :after doom-modeline
        :hook (doom-modeline-mode-hook)
        :custom ((nyan-cat-face-number . 4)
                 (nyan-animate-nyancat . t)))
   #+END_SRC
** Refactor
*** emr
    #+BEGIN_SRC emacs-lisp
      (leaf emr
        :ensure t
        :bind ("M-RET" . emr-show-refactor-menu))
    #+END_SRC
** Completion
*** ac-slime
    #+BEGIN_SRC emacs-lisp
      (leaf auto-complete
        :ensure t
        :config
        (leaf ac-slime
          :ensure t
          :hook ((slime-mode-hook . set-up-slime-ac)
                 (slime-repl-mode-hook . set-up-slime-ac))
          :config
          (add-to-list 'ac-modes 'slime-repl-mode)))

    #+END_SRC
*** company
   #+BEGIN_SRC emacs-lisp
     (leaf company
       :ensure t
       :defvar company-backends
       :init
       (global-company-mode)
       :bind
       (:company-active-map
        ("C-n" . company-select-next)
        ("C-p" . company-select-previous)))
   #+END_SRC
*** company-glsl
    #+BEGIN_SRC emacs-lisp
      (leaf company-glsl
        :ensure t
        :after company
        :config
        (add-to-list 'company-backends 'company-glsl))
    #+END_SRC
*** company-lsp
    #+BEGIN_SRC emacs-lisp
      (leaf company-lsp
        :ensure t
        :after company
        :config
        (push 'company-lsp company-backends))
    #+END_SRC
*** company-irony
    #+begin_src emacs-lisp
      (leaf company-irony
        :ensure t
        :after (company irony)
        :config
        (push 'company-irony company-backends))
    #+end_src
** LSP
*** lsp-mode
    #+BEGIN_SRC emacs-lisp
      (leaf lsp-mode :ensure t)
    #+END_SRC
*** lsp-ui
    #+BEGIN_SRC emacs-lisp
      (leaf lsp-ui
        :ensure t
        :after lsp
        :bind (("M-." . lsp-ui-peek-find-definitions)
               ("M-?" . lsp-ui-peek-find-implementation))
        :hook (lsp-mode-hook)
        :config
        (with-eval-after-load 'lsp-ui
          (setq-default lsp-ui-doc-enable t
                        lsp-ui-doc-max-height 15
                        lsp-ui-sideline-enable nil
                        lsp-ui-imenu-enable nil
                        lsp-ui-sideline-enable nil)))
    #+END_SRC
*** dap-mode
    #+BEGIN_SRC emacs-lisp
      (leaf dap-mode
        :ensure t
        :bind
        (:dap-mode-map
         ("C-c d" . dap-breakpoint-toggle))
        :config
        (with-eval-after-load 'dap-mode
          (dap-mode 1)
          (dap-ui-mode 1)))
   #+END_SRC
** Git
*** magit
    #+BEGIN_SRC emacs-lisp
      (leaf magit :ensure t)
    #+END_SRC
*** git-gutter-fringe
    #+BEGIN_SRC emacs-lisp
      (leaf git-gutter-fringe
        :disabled t
        :ensure t
        :config
        (global-git-gutter-mode 1))
    #+END_SRC
** Search
*** counsel
    #+BEGIN_SRC emacs-lisp
      (leaf ivy
        :ensure t
        :custom (ivy-use-virtual-buffers . t)
        :config (ivy-mode 1))

      (leaf counsel
        :ensure t
        :init
        (eval-and-compile
          (defun takeokunn/counsel-ag nil
            (interactive)
            (let ((symbol (thing-at-point 'symbol 'no-properties))
                  (default-directory (locate-dominating-file default-directory ".git")))
              (counsel-ag symbol))))
        :bind
        ("C-x m" . counsel-compile)
        ("C-c k" . takeokunn/counsel-ag)
        :custom (counsel-ag-base-command . "ag --nocolor --nogroup -u %s")
        :config
        (counsel-mode 1))
    #+END_SRC
*** ivy-ghq
    #+BEGIN_SRC emacs-lisp
      (leaf ivy-ghq
        :el-get (ivy-ghq
                 :url "https://github.com/analyticd/ivy-ghq.git"
                 :features ivy-ghq)
        :preface
        (defun takeokunn/ivy-ghq-open-and-fzf ()
          (interactive)
          (ivy-ghq-open)
          (counsel-fzf))
        :after counsel
        :custom ((ivy-ghq-short-list . t))
        :defun ivy-ghq-open takeokunn/ivy-ghq-open-and-fzf)

      (general-define-key
       "M-o" 'takeokunn/ivy-ghq-open-and-fzf)
    #+END_SRC
*** ivy-rich
    #+BEGIN_SRC emacs-lisp
      (leaf ivy-rich
	:ensure t
	:after counsel
	:config
	(ivy-rich-mode 1))
    #+END_SRC
*** helm-swoop
    #+begin_src emacs-lisp
      (leaf helm
        :ensure t
        :config
        (leaf helm-swoop
          :ensure t
          :defun helm-swoop
          :bind ("C-o" . helm-swoop)
          :custom (helm-swoop-split-direction . 'split-window-horizontally)))
    #+end_src
** Shell
*** exec-path-from-shell
    #+BEGIN_SRC emacs-lisp
      (leaf exec-path-from-shell
	:ensure t
	:hook ((after-init-hook . my-exec-path-from-shell-initialize))
	:init
	(eval-and-compile
	  (defun my-exec-path-from-shell-initialize nil
	    (when (memq window-system
			'(mac ns x))
	      (exec-path-from-shell-copy-envs
	       '("PATH" "GEM_HOME" "GOPATH"))
	      (exec-path-from-shell-initialize)))))
    #+END_SRC
** Rust
*** racer
    #+BEGIN_SRC emacs-lisp
      (leaf racer
	:ensure t
	:after rust-mode
	:hook (rust-mode-hook
	       (racer-mode-hook . eldoc-mode)))
    #+END_SRC
*** TODO rustic
    #+BEGIN_SRC emacs-lisp
      ;; (leaf rustic
      ;;   :ensure t
      ;;   :after rust-mode
      ;;   :hook (rust-mode-hook
      ;; 	 (rustic-mode-hook . eldoc-mode))
    #+END_SRC
** C#
*** TODO omnisharp
    #+BEGIN_SRC emacs-lisp
      ;; (leaf omnisharp
      ;;   :ensure t
      ;;   :after company flycheck
      ;;   :hook (csharp-mode-hook . flycheck-mode)
      ;;   :config
      ;;   (add-to-list 'company-backends 'company-omnisharp))
    #+END_SRC
** JavaScript
*** js2-refactor
    #+BEGIN_SRC emacs-lisp
      (leaf js2-refactor
        :ensure t
        :after typescript-mode js2-mode
        :hook (js2-mode-hook typescript-mode-hook))
    #+END_SRC
*** tide
    #+BEGIN_SRC emacs-lisp
      (leaf tide
        :ensure t
        :config
        (eval-and-compile
          (defun takeokunn/setup-tide-mode ()
            (interactive)
            (tide-setup)
            (tide-hl-identifier-mode 1)))
        (with-eval-after-load 'typescript-mode
          (add-hook 'typescript-mode-hook #'takeokunn/setup-tide-mode)))
    #+END_SRC
** Haskell
*** hindent
    #+BEGIN_SRC emacs-lisp
      (leaf hindent
        :ensure t
        :after haskell-mode
        :hook (haskell-mode-hook))
    #+END_SRC
** Ruby
*** robe
    #+begin_src emacs-lisp
      (leaf robe
	:ensure t
	:after ruby-mode company
	:hook (ruby-mode-hook)
	:config
	(push 'company-robe company-backends))
    #+end_src
*** rubocop
    #+begin_src emacs-lisp
      (leaf rubocop
	:ensure t
	:after ruby-mode
	:hook (ruby-mode-hook))
    #+end_src
*** ruby-refactor
    #+BEGIN_SRC emacs-lisp
      (leaf ruby-refactor
        :ensure t
        :hook ((ruby-mode-hook . ruby-refactor-mode-launch)))
    #+END_SRC
** SQL
*** sql-indent
    #+BEGIN_SRC emacs-lisp
      (leaf sql-indent
	:ensure t
	:after sql-mode
	:hook ((sql-mode-hook . sqlind-minor-mode)))
    #+END_SRC
** C/C++
*** irony-mode
    #+begin_src emacs-lisp
      (leaf irony
        :ensure t
        :hook ((c-mode-common-hook . irony-mode)
               (irony-mode-hook . irony-cdb-autosetup-compile-options)))
    #+end_src
** File
*** recentf
    #+BEGIN_SRC emacs-lisp
      (leaf recentf
	:ensure t
	:setq-default ((recentf-max-saved-items . 10000)
		       (recentf-auto-cleanup quote never)
		       (recentf-save-file . "~/.emacs.d/.recentf")
		       (recentf-exclude quote
					(".recentf")))
	:config
	(recentf-mode 1))
    #+END_SRC
*** open-junk-file
    #+BEGIN_SRC emacs-lisp
      (leaf open-junk-file
        :ensure t
        :bind
        ("C-x j" . open-junk-file)
        :custom (open-junk-file-format . "~/.emacs.d/.junk/%Y-%m%d-%H%M%S."))
    #+END_SRC
** Syntax
*** flycheck
    #+begin_src emacs-lisp
      (leaf flycheck
	:ensure t
	:after ruby-mode
	:hook (ruby-mode-hook))
    #+end_src
** Cursor
*** smartrep/multiple-cursors
    #+BEGIN_SRC emacs-lisp
      (leaf smartrep :ensure t)

      (leaf multiple-cursors
	:ensure t
	:defun (smartrep-define-key . smartrep)
	:after smartrep
	:config
	(global-unset-key (kbd "C-t"))
	(smartrep-define-key global-map "C-t"
			     '(("C-t" quote mc/mark-next-like-this)
			       ("n" quote mc/mark-next-like-this)
			       ("p" quote mc/mark-previous-like-this)
			       ("m" quote mc/mark-more-like-this-extended)
			       ("u" quote mc/unmark-next-like-this)
			       ("U" quote mc/unmark-previous-like-this)
			       ("s" quote mc/skip-to-next-like-this)
			       ("S" quote mc/skip-to-previous-like-this)
			       ("*" quote mc/mark-all-like-this)
			       ("d" quote mc/mark-all-like-this-dwim)
			       ("i" quote mc/insert-numbers)
			       ("o" quote mc/sort-regions)
			       ("O" quote mc/reverse-regions))))
    #+END_SRC
*** smooth-scroll
    #+BEGIN_SRC emacs-lisp
      (leaf smooth-scroll
        :ensure t
        :commands smooth-scroll-mode
        :config
        (smooth-scroll-mode 1))
    #+END_SRC
** Other
*** ace-window
    #+BEGIN_SRC emacs-lisp
      (leaf ace-window
        :ensure t
        :custom ((aw-keys '(97 115 100 102 103 104 106 107 108))))
    #+END_SRC
*** dashboard
    #+BEGIN_SRC emacs-lisp
      (leaf dashboard
	:ensure t
	:config
	(dashboard-setup-startup-hook))
    #+END_SRC
*** ddskk
    #+BEGIN_SRC emacs-lisp
      (leaf ddskk
        :ensure t
        :bind
        ("C-x C-j" . skk-mode)
        :setq
        (skk-byte-compile-init-file . t)
        (skk-preload . t)
        (skk-isearch-mode-enable . 'always)
        (default-input-method . "japanese-skk"))
    #+END_SRC
*** editorconfig
    #+BEGIN_SRC emacs-lisp
      (leaf editorconfig
	:ensure t
	:config
	(editorconfig-mode 1))
    #+END_SRC
*** esup
    #+BEGIN_SRC emacs-lisp
      (leaf esup :ensure t)
    #+END_SRC
*** font-lock-studio
    #+BEGIN_SRC emacs-lisp
      (leaf font-lock-studio :ensure t)
    #+END_SRC
*** google-this
    #+BEGIN_SRC emacs-lisp
      (leaf google-this
	:ensure t
	:bind
	("M-g" . google-this))
    #+END_SRC
*** goto-addr
    #+BEGIN_SRC emacs-lisp
      (leaf goto-addr
	:ensure t
	:commands goto-address-prog-mode goto-address-mode
	:hook ((prog-mode-hook . goto-address-prog-mode)
	       (text-mode-hook . goto-address-mode)))
    #+END_SRC
*** helpful
    #+BEGIN_SRC emacs-lisp
      (leaf helpful
        :ensure t
        :after counsel
        :bind
        (("C-? f" . helpful-callable)
         ("C-? v" . helpful-variable)
         ("C-? k" . helpful-key)
         ("C-? C-d" . helpful-at-point)
         ("C-? F" . helpful-function)
         ("C-? C" . helpful-command))
        :custom ((counsel-describe-function-function function helpful-callable)
                 (counsel-describe-variable-function function helpful-variable)))
    #+END_SRC
*** smartparens
    #+BEGIN_SRC emacs-lisp
      (leaf smartparens :ensure t)
    #+END_SRC
*** smex
    #+BEGIN_SRC emacs-lisp
      (leaf smex :ensure t)
    #+END_SRC
*** undo
    #+begin_src emacs-lisp
      (leaf undo-tree
        :ensure t
        :config (global-undo-tree-mode))
    #+end_src
*** whitespace
    #+BEGIN_SRC emacs-lisp
      (leaf whitespace
        :ensure t
        :custom
        ((whitespace-style '(face tabs tab-mark spaces space-mark))
         (whitespace-display-mappings '((space-mark ?\u3000 [?\u25a1])
                                            (tab-mark ?\t [?\xBB ?\t] [?\\ ?\t]))))
        :config
        (global-whitespace-mode 1))
    #+END_SRC
* Eshell
** basic
   #+begin_src emacs-lisp
     (leaf eshell
       :after (counsel)
       :config
       (with-eval-after-load 'eshell
         ;; function
         (defun eshell/ff (&rest args)
           (find-file (car args)))

         ;; config
         (setq eshell-cmpl-ignore-case t)
         (setq eshell-glob-include-dot-dot nil)
         (setq eshell-ask-to-save-history (quote always))
         (setq eshell-history-size 100000)
         (setq eshell-hist-ignoredups t)

         ;; alias
         (defvar *shell-alias* '(("ll" "ls -la")
                                 ("cdd" "cd ~/Desktop")))
         (defvar eshell-command-aliases-list (append *shell-alias*))))
   #+end_src
** aweshell
    #+BEGIN_SRC emacs-lisp
      (defun takeokunn/aweshell-setup ()
        (shell-command-to-string "ghq get https://github.com/takeokunn/aweshell.git"))

      (when (file-directory-p "~/.ghq/github.com/takeokunn/aweshell")
        (add-to-list 'load-path (expand-file-name "~/.ghq/github.com/takeokunn/aweshell"))
        (require 'aweshell)
        (with-eval-after-load 'aweshell
          (defun takeokunn/counsel-aweshell-history ()
            (interactive)
            (ivy-read "Aweshell history: " (aweshell-parse-shell-history)))

          (add-hook 'eshell-mode-hook
                    (lambda () (define-key eshell-mode-map (kbd "C-c C-r") 'takeokunn/counsel-aweshell-history)))
          (setq aweshell-auto-suggestion-p nil
                eshell-highlight-prompt t
                eshell-prompt-function 'epe-theme-lambda)))
    #+END_SRC
** eshell-z
   #+begin_src emacs-lisp
     (leaf eshell-z
       :ensure t
       :bind (("C-c C-q" . eshell-z)))
   #+end_src
* Org Mode
** Settinngs
   #+BEGIN_SRC emacs-lisp
     (setq-default org-use-speed-commands t
                     org-agenda-todo-ignore-with-date t
                     org-directory "~/org"
                     org-agenda-files '("~/org/todo.org")
                     org-todo-keywords '((sequence "TODO(t)" "WAIT(w)" "|" "DONE(d)"))
                     org-capture-templates '(("t" "Todo" entry (file+datetree "~/org/todo.org")
                                              "* %?")
                                             ("b" "Blog" entry (file "~/org/blog.org")
                                              "* %?")
                                             ("m" "Memo" entry (file "~/org/memo.org")
                                              "* %?")))
     (leaf org-temp)
   #+END_SRC
** Keybind
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      :prefix "C-c"
      "a" 'org-agenda
      "b" 'counsel-bookmark
      "c" 'org-capture)

     (general-define-key
      :keymaps 'org-mode-map
      "C-m" nil)
   #+END_SRC
* MyFunc
** takeokunn/beginning-of-intendation
   #+BEGIN_SRC emacs-lisp
     (defun takeokunn/beginning-of-intendation ()
       "move to beginning of line, or indentation"
       (interactive)
       (back-to-indentation))
   #+END_SRC
** takeokunn/before-set-auto-mode
   #+BEGIN_SRC emacs-lisp
     (defun takeokunn/before-set-auto-mode ()
       (when (or (and buffer-file-name
                      (> (file-attribute-size (file-attributes buffer-file-name)) 100000))
                 (> (line-number-at-pos (point-max)) 10000))
         (prog1 t
           (prog-mode))))

     (advice-add 'set-auto-mode :before-until 'takeokunn/before-set-auto-mode)
   #+END_SRC
** takeokunn/irb-history
   #+BEGIN_SRC emacs-lisp
      (defun takeokunn/irb-history ()
        (interactive)
        (insert
         (completing-read
          "choose history: "
          (mapcar #'list (-distinct (s-lines (f-read-text "~/.irb-history")))))))

      (general-def inf-ruby-mode-map
        "C-c C-r" 'takeokunn/irb-history)
   #+END_SRC
** takeokunn/reload-major-mode
   #+BEGIN_SRC emacs-lisp
     (defun takeokunn/reload-major-mode ()
       "Reload current major mode."
       (interactive)
       (let ((current-mode major-mode))
         (fundamental-mode)
         (funcall current-mode)
         current-mode))
   #+END_SRC
** TODO takeokunn/exec-npm-script
   #+BEGIN_SRC emacs-lisp
     ;; (defun my/exec-npm-script ()
     ;;   (interactive)
     ;;   (let* ((npm-root (and default-directory (locate-dominating-file default-directory "package.json")))
     ;;          (default-directory (or npm-root default-directory))
     ;;          choice scripts command-names)
     ;;     (unless npm-root
     ;;       (user-error "package.json not found..."))
     ;;     (setq scripts (cdr-safe (assq 'scripts (json-read-file (file-relative-name "package.json" default-directory)))))
     ;;     (setq command-names (mapcar #'(lambda (s) (symbol-name (car s))) scripts))
     ;;     (setq choice (intern (completing-read "choice command: " command-names)))
     ;;     (setq command (cdr-safe (assq choice scripts)))
     ;;     (when command
     ;;       (compile command))))
   #+END_SRC
