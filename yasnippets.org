#+title: Yasnippet Configurations
#+author: takeounn
#+email: bararararatty@gmail.com
#+startup: content
#+startup: nohideblocks
#+options: num:t auto-id:t
#+setupfile: theme-readtheorg.setup
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* yasnippet
** default
   :PROPERTIES:
   :org-generate-root: ~/.emacs.d/yasnippets
   :END:
*** dockerfile-mode/
**** dockerize
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: dockerize
# key: dockerize
# expand-env: ((yas-indent-line 'fixed) (yas-wrap-around-region nil))
# --

ENV DOCKERIZE_VERSION ${1:v0.6.1}

`(pcase (yas-choose-value "ubuntu" "alpine")
   ("ubuntu" (concat
               "RUN wget https://github.com/jwilder/dockerize/releases/download/${DOCKERIZE_VERSION}/dockerize-linux-amd64-${DOCKERIZE_VERSION}.tar.gz && \\\n"
               "    tar -C /usr/local/bin -xzvf dockerize-linux-amd64-${DOCKERIZE_VERSION}.tar.gz && \\\n"
               "    rm dockerize-linux-amd64-${DOCKERIZE_VERSION}.tar.gz"))
   ("alpine" (concat
               "RUN apk add --no-cache openssl && \\\n"
               "    wget https://github.com/jwilder/dockerize/releases/download/${DOCKERIZE_VERSION}/dockerize-alpine-linux-amd64-${DOCKERIZE_VERSION}.tar.gz && \\\n"
               "    tar -C /usr/local/bin -xzvf dockerize-alpine-linux-amd64-${DOCKERIZE_VERSION}.tar.gz && \\\n"
               "    rm dockerize-alpine-linux-amd64-${DOCKERIZE_VERSION}.tar.gz")))`
#+END_SRC
*** emacs-lisp-mode/
**** .read_me
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
-*- coding: utf-8 -*-
Originally started by Xah Lee (xahlee.org) on 2009-02-22
Released under GPL 3.

Feel free to add missing ones or modify existing ones to improve.

Those starting with “x-” are supposed to be idiom templates. Not sure it's very useful. They might start with “i-” or "id-" in the future.
#+END_SRC
**** add-hook
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: add-hook
# key: add-hook
# key: ah
# --
(add-hook '${1:name}-hook ${2:'${3:function}})$0

#+END_SRC
**** and
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: and
# key: and
# key: a
# --
(and $0)
#+END_SRC
**** aref
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: aref
# key: aref
# --
(aref ${1:array} ${2:index})

#+END_SRC
**** aset
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: aset
# key: aset
# --
(aset ${1:array} ${2:index} ${3:element})
#+END_SRC
**** assq
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: assq
# key: assq
# --
(assq ${1:key} ${2:list})
#+END_SRC
**** autoload
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: autoload
# key: autoload
# --
(autoload ${1:function} "${2:filename}"${3: "docstring"}${4: interactive}${5: type})
#+END_SRC
**** backward-char
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: backward-char
# key: backward-char
# key: bc
# --
(backward-char $0)
#+END_SRC
**** beginning-of-line
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: beginning-of-line
# key: beginning-of-line
# key: bol
# --
(beginning-of-line)
#+END_SRC
**** bounds-of-thing-at-point
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: bounds-of-thing-at-point
# key: bounds-of-thing-at-point
# key: botap
# --
(bounds-of-thing-at-point $0)
#+END_SRC
**** buffer-file-name
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: buffer-file-name
# key: buffer-file-name
# key: bfn
# --
(buffer-file-name)
#+END_SRC
**** buffer-modified-p
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: buffer-modified-p
# key: buffer-modified-p
# key: bmp
# --
(buffer-modified-p $0)
#+END_SRC
**** buffer-substring
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: buffer-substring
# key: buffer-substring
# key: bs
# --
(buffer-substring ${1:start} ${2:end})
#+END_SRC
**** buffer-substring-no-properties
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: buffer-substring-no-properties
# key: buffer-substring-no-properties
# key: bsnp
# --
(buffer-substring-no-properties ${1:start} ${2:end})
#+END_SRC
**** cond
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: cond
# key: cond
# --
(cond
 (${1:condition} ${2:body})$0)
#+END_SRC
**** condition-case
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: condition-case
# key: condition-case
# key: cc
# --
(condition-case $0)
#+END_SRC
**** const
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: defconst
# key: const
# --
(defconst ${1:name} ${2:value}${3: "${4:docstring}"})$0
#+END_SRC
**** copy-directory
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: copy-directory
# key: copy-directory
# key: cd
# --
(copy-directory ${1:directory} {2:target}${3: keep-time}${4: parents})
#+END_SRC
**** copy-file
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: copy-file
# key: copy-file
# key: cf
# --
(copy-file ${1:filename} ${2:newname}${3: ok-if-already-exists}${4: keep-time}{5: preserve-uid-gid})
#+END_SRC
**** current-buffer
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: current-buffer
# key: current-buffer
# key: cb
# --
(current-buffer)
#+END_SRC
**** custom-autoload
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: custom-autoload
# key: custom-autoload
# key: ca
# --
(custom-autoload ${1:symbol} ${2:load}${3: noset})
#+END_SRC
**** defalias
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: defalias
# key: defalias
# --
(defalias '${1:symbol} '${2:alias}${3: "docstring"})
#+END_SRC
**** defcustom
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: defcustom
# key: defcustom
# --
(defcustom ${1:symbol} ${2:standard} "${3:docstring}"${4: args})
#+END_SRC
**** define-key
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: define-key
# key: define-key
# key: dk
# --
(define-key ${1:mode}-map (kbd "${2:key}") $0)
#+END_SRC
**** defun
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: defun
# key: def
# --
(defun ${1:fun} (${2:args})
  "${3:docstring}"
  ${4:(interactive${5: "${6:P}"})}
  $0)
#+END_SRC
**** defvar
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: defvar
# key: defvar
# --
(defvar ${1:symbol} ${2:initvalue} "${3:docstring}")
#+END_SRC
**** delete-char
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: delete-char
# key: delete-char
# key: dc
# --
(delete-char $0)
#+END_SRC
**** delete-directory
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: delete-directory
# key: delete-directory
# key: dd
# --
(delete-directory ${1:dicretory}${2: recursive})
#+END_SRC
**** delete-file
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: delete-file
# key: delete-file
# key: df
# --
(delete-file $0)
#+END_SRC
**** delete-region
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: delete-region
# key: delete-region
# key: dr
# --
(delete-region $0)
#+END_SRC
**** directory-files
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: directory-files
# key: directory-files
# key: df
# --
(directory-files ${1:directory}${2: full}${3: match}${4: nosort})
#+END_SRC
**** dired.process_marked
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: process marked files in dired
# contributor : Xah Lee
# --
;; idiom for processing a list of files in dired's marked files

;; suppose myProcessFile is your function that takes a file path
;; and do some processing on the file

(defun dired-myProcessFile ()
  "apply myProcessFile function to marked files in dired."
  (interactive)
  (require 'dired)
  (mapc 'myProcessFile (dired-get-marked-files))
)

;; to use it, type M-x dired-myProcessFile
#+END_SRC
**** end-of-line
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: end-of-line
# key: end-of-line
# key: eol
# --
(end-of-line)
#+END_SRC
**** error
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: error
# key: error
# --
(error "${1:message}"${2: format-args})
#+END_SRC
**** ert-deftest
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Raghav Kumar Gautam
# name: ert-deftest
# key: edt
# --
(ert-deftest ${1:test-name} ()
  $0)

#+END_SRC
**** expand-file-name
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: expand-file-name
# key: expand-file-name
# key: efn
# --
(expand-file-name $0)
#+END_SRC
**** fboundp
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: fboundp
# key: fboundp
# --
(fboundp '$0)
#+END_SRC
**** file-name-directory
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: file-name-directory
# key: file-name-directory
# key: fnd
# --
(file-name-directory $0)
#+END_SRC
**** file-name-extension
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: file-name-extension
# key: file-name-extension
# key: fne
# --
(file-name-extension ${1:filename}${2: period})
#+END_SRC
**** file-name-nondirectory
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: file-name-nondirectory
# key: file-name-nondirectory
# key: fnn
# --
(file-name-nondirectory $0)
#+END_SRC
**** file-name-sans-extension
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: file-name-sans-extension
# key: file-name-sans-extension
# key: fnse
# --
(file-name-sans-extension $0)
#+END_SRC
**** file-relative-name
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: file-relative-name
# key: file-relative-name
# key: frn
# --
(file-relative-name $0)
#+END_SRC
**** file.process
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: a function that process a file
# contributor : Xah Lee
# --
(defun doThisFile (fpath)
  "Process the file at path FPATH ..."
  (let ()
    ;; create temp buffer without undo record or font lock. (more efficient)
    ;; first space in temp buff name is necessary
    (set-buffer (get-buffer-create " myTemp"))
    (insert-file-contents fpath nil nil nil t)

    ;; process it ...
    ;; (goto-char 0) ; move to begining of file's content (in case it was open)
    ;; ... do something here
    ;; (write-file fpath) ;; write back to the file

    (kill-buffer " myTemp")))
#+END_SRC
**** file.read-lines
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: read lines of a file
# contributor : Xah Lee
# --
(defun read-lines (filePath)
  "Return a list of lines in FILEPATH."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string
     (buffer-string) "\n" t)))

;; process all lines
(mapc
 (lambda (aLine)
   (message aLine) ; do your stuff here
   )
 (read-lines "inputFilePath")
)
#+END_SRC
**** find-file
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: find-file
# key: find-file
# key: ff
# --
(find-file $0)
#+END_SRC
**** find-replace
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: find and replace on region
# contributor : Xah Lee
# --
(defun replace-html-chars-region (start end)
  "Replace “<” to “&lt;” and other chars in HTML.
This works on the current region."
  (interactive "r")
  (save-restriction
    (narrow-to-region start end)
    (goto-char (point-min))
    (while (search-forward "&" nil t) (replace-match "&amp;" nil t))
    (goto-char (point-min))
    (while (search-forward "<" nil t) (replace-match "&lt;" nil t))
    (goto-char (point-min))
    (while (search-forward ">" nil t) (replace-match "&gt;" nil t))
    )
  )
#+END_SRC
**** format
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: format
# key: f
# --
(format "${1:message}" ${2:format-args})
#+END_SRC
**** forward-char
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: forward-char
# key: forward-char
# key: fc
# --
(forward-char $0)
#+END_SRC
**** forward-line
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: forward-line
# key: forward-line
# key: fl
# --
(forward-line $0)
#+END_SRC
**** get
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: get
# key: get
# --
(get ${1:symbol} {2:propname})
#+END_SRC
**** global-set-key
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: global-set-key
# key: global-set-key
# key: gsk
# --
(global-set-key (kbd "${1:key}") $0)
#+END_SRC
**** goto-char
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: goto-char
# key: goto-char
# key: gc
# --
(goto-char $0)
#+END_SRC
**** grabstring
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: grab buffer substring
# contributor : Xah Lee
# --
(setq $0 (buffer-substring-no-properties myStartPos myEndPos))
#+END_SRC
**** grabthing
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: grab word under cursor
# contributor : Xah Lee
# --
(setq $0 (thing-at-point 'symbol))
#+END_SRC
**** header
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: kchenphy <https://www.github.com/kchenphy>
# name: package header
# key: header
# --
;;; ${1:name}.el --- ${2:summary} -*- lexical-binding: t -*-

;; Author: ${3:`(user-full-name)`}
;; Maintainer: ${4:`(user-full-name)`}
;; Version: ${5:version}
;; Package-Requires: (${6:dependencies})
;; Homepage: ${7:homepage}
;; Keywords: ${8:keywords}

${9:
;; This file is not part of GNU Emacs

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; For a full copy of the GNU General Public License
;; see <http://www.gnu.org/licenses/>.
}

;;; Commentary:

;; ${10:commentary}

;;; Code:

${11:(message "Hello World!")}

(provide '$1)

;;; $1.el ends here
#+END_SRC
**** insert
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: insert
# key: insert
# key: i
# --
(insert $0)
#+END_SRC
**** insert-file-contents
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: insert-file-contents
# key: insert-file-contents
# key: ifc
# --
(insert-file-contents ${1:filename}${2: visit}${3: beg}${4: end}${5: replace})
#+END_SRC
**** interactive
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: interactive
# key: interactive
# --
(interactive${1: "${2:P}"})
#+END_SRC
**** kbd
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: kbd
# key: kbd
# --
(kbd "$0")
#+END_SRC
**** kill-buffer
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: kill-buffer
# key: kill-buffer
# key: kb
# --
(kill-buffer $0)
#+END_SRC
**** lambda
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: lambda
# key: lam
# --
(lambda ($1) ${2:(interactive${3: "$4"}) }$0)

#+END_SRC
**** let
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: let
# key: let
# key: l
# --
(let${1:*} (${2:args})
  $0)
#+END_SRC
**** line-beginning-position
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: line-beginning-position
# key: line-beginning-position
# key: lbp
# --
(line-beginning-position)
#+END_SRC
**** line-end-position
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: line-end-position
# key: line-end-position
# key: lep
# --
(line-end-position)
#+END_SRC
**** looking-at
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: looking-at
# key: looking-at
# key: la
# --
(looking-at $0)
#+END_SRC
**** make-directory
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: make-directory
# key: make-directory
# key: md
# --
(make-directory ${1:directory}${2: parents})
#+END_SRC
**** make-local-variable
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: make-local-variable
# key: make-local-variable
# key: mlv
# --
(make-local-variable $0)
#+END_SRC
**** mapc
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: mapc
# key: mapc
# --
(mapc ${1:function} $0)
#+END_SRC
**** match-beginning
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: match-beginning
# key: match-beginning
# key: mb
# --
(match-beginning $0)
#+END_SRC
**** match-end
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: match-end
# key: match-end
# key: me
# --
(match-end $0)
#+END_SRC
**** match-string
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: match-string
# key: match-string
# key: ms
# --
(match-string $0)
#+END_SRC
**** memq
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: memq
# key: memq
# --
(memq ${1:element} ${2:list})
#+END_SRC
**** message
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: message
# key: message
# key: m
# --
(message "${1:message}"${2: format-args})
#+END_SRC
**** minor_mode
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: minor_mode
# key: minor
# --
(defvar ${1:mode}-modeline-indicator " ${2:indicator}"
  "call ($1-install-mode) again if this is changed")

(defvar $1-mode nil)
(make-variable-buffer-local '$1-mode)
(put '$1-mode 'permanent-local t)

(defun $1-mode (&optional arg)
  "$0"
  (interactive "P")
  (setq $1-mode
        (if (null arg) (not $1-mode)
          (> (prefix-numeric-value arg) 0)))
  (force-mode-line-update))

(provide '$1-mode)
#+END_SRC
**** not
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: not
# key: not
# key: n
# --
(not $0)
#+END_SRC
**** nth
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: nth
# key: nth
# --
(nth ${1:index} ${2:list})
#+END_SRC
**** number-to-string
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: number-to-string
# key: number-to-string
# key: nts
# --
(number-to-string $0)
#+END_SRC
**** or
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: or
# key: or
# key: o
# --
(or $0)
#+END_SRC
**** point
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: point
# key: point
# key: p
# --
(point)
#+END_SRC
**** point-max
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: point-max
# key: point-max
# --
(point-max)
#+END_SRC
**** point-min
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: point-min
# key: point-min
# key: pm
# --
(point-min)
#+END_SRC
**** put
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: put
# key: put
# --
(put ${1:symbol} ${2:propname} ${3:value})
#+END_SRC
**** re-search-backward
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: re-search-backward
# key: re-search-backward
# key: rsb
# --
(re-search-backward ${1:regexp}${2: bound}${3: noerror}${4: count})
#+END_SRC
**** re-search-forward
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: re-search-forward
# key: re-search-forward
# key: rsf
# --
(re-search-forward ${1:regexp}${2: bound}${3: noerror}${4: count})
#+END_SRC
**** region-active-p
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: region-active-p
# key: region-active-p
# key: rap
# --
(region-active-p)
#+END_SRC
**** region-beginning
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: region-beginning
# key: region-beginning
# key: rb
# --
(region-beginning)
#+END_SRC
**** region-end
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: region-end
# key: region-end
# key: re
# --
(region-end)
#+END_SRC
**** rename-file
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: rename-file
# key: rename-file
# key: rf
# --
(rename-file ${1:file} ${2:newname}${3: ok-if-already-exists})
#+END_SRC
**** replace-regexp
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: replace-regexp
# key: replace-regexp
# key: rr
# --
(replace-regexp ${1:regexp}${2: delimited}${3: start}${4: end})
#+END_SRC
**** replace-regexp-in-string
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: replace-regexp-in-string
# key: replace-regexp-in-string
# key: rris
# --
(replace-regexp-in-string ${1:regexp} ${2:rep} ${3:string}${4: fixedcase}${5: literal}${6: subexp}${7: start})
#+END_SRC
**** save-buffer
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: save-buffer
# key: save-buffer
# key: sb
# --
(save-buffer $0)
#+END_SRC
**** save-excursion
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: save-excursion
# key: save-excursion
# key: se
# --
(save-excursion $0)
#+END_SRC
**** search-backward
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: search-backward
# key: search-backward
# key: sb
# --
(search-backward "$1"${2: ${3:bound}${4: ${5:noerror}${6: count}}})$0

#+END_SRC
**** search-backward-regexp
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: search-backward-regexp
# key: search-backward-regexp
# key: sbr
# --
(search-backward-regexp "$1"${2: ${3:bound}${4: ${5:noerror}${6: count}}})$0

#+END_SRC
**** search-forward
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: search-forward
# key: search-forward
# key: sf
# --
(search-forward "$1"${2: ${3:bound}${4: ${5:noerror}${6: count}}})$0

#+END_SRC
**** search-forward-regexp
#+BEGIN_SRC snippet
# -*- mode: snippet; -*-
# contributor: Xah Lee (XahLee.org)
# name: search-forward-regexp
# key: search-forward-regexp
# key: sfr
# --
(search-forward-regexp "$1"${2: ${3:bound}${4: ${5:noerror}${6: count}}})$0

#+END_SRC
**** set-buffer
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: set-buffer
# key: set-buffer
# key: sb
# --
(set-buffer $0)
#+END_SRC
**** set-file-modes
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: set-file-modes
# key: set-file-modes
# key: sfm
# --
(set-file-modes ${1:filename} $0)
#+END_SRC
**** set-mark
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: set-mark
# key: set-mark
# key: sm
# --
(set-mark $0)
#+END_SRC
**** setq
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: setq
# key: setq
# key: s
# --
(setq $0)
#+END_SRC
**** should
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Raghav Kumar Gautam
# name: should
# key: sh
# --
(should $0)
#+END_SRC
**** skip-chars-backward
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: skip-chars-backward
# key: skip-chars-backward
# key: scb
# --
(skip-chars-backward "${1:string}"${2: lim})
#+END_SRC
**** skip-chars-forward
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: skip-chars-forward
# key: skip-chars-forward
# key: scf
# --
(skip-chars-forward "${1:string}"${2: lim})
#+END_SRC
**** split-string
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: split-string
# key: split-string
# key: ss
# --
(split-string ${1:string}${2: separators}${3: omit-nulls})
#+END_SRC
**** string-match
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: string-match
# key: string-match
# key: sm
# --
(string-match "${1:regexp}" "${2:string}"${3: start})
#+END_SRC
**** string-to-number
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: string-to-number
# key: string-to-number
# key: stn
# --
(string-to-number $0)
#+END_SRC
**** string=
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: string=
# key: string=
# --
(string= $0)
#+END_SRC
**** substring
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: substring
# key: substring
# --
(substring ${1:string} ${2:from}${3: to})
#+END_SRC
**** thing-at-point
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: thing-at-point
# key: thing-at-point
# key: tap
# --
(thing-at-point ${1:thing}${2: no-properties})
#+END_SRC
**** traverse_dir
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: traversing a directory
# contributor : Xah Lee
# --
;; apply a function to all files in a dir
(require 'find-lisp)
(mapc 'my-process-file (find-lisp-find-files "~/myweb/" "\\.html$"))
#+END_SRC
**** use-package
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Daniel Hitzel
# name: use-package
# key: up
# --
(use-package ${1:package-name}
:ensure t$0)
#+END_SRC
**** use-package-binding
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Daniel Hitzel
# name: use-package binding
# key: upb
# --
:bind ("${1:binding}" . ${2:function-name})
#+END_SRC
**** vector
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: vector
# key: vector
# key: v
# --
(vector $0)
#+END_SRC
**** when
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: when
# key: w
# --
(when $0)
#+END_SRC
**** widget-get
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: widget-get
# key: widget-get
# key: wg
# --
(widget-get $0)
#+END_SRC
**** with-current-buffer
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: with-current-buffer
# key: with-current-buffer
# key: wcb
# --
(with-current-buffer $0)
#+END_SRC
**** word-or-region
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: Command that works on region or word
# contributor : Xah Lee
# --
;; example of a command that works on current word or text selection
(defun down-case-word-or-region ()
  "Lower case the current word or text selection."
(interactive)
(let (pos1 pos2 meat)
  (if (and transient-mark-mode mark-active)
      (setq pos1 (region-beginning)
            pos2 (region-end))
    (setq pos1 (car (bounds-of-thing-at-point 'symbol))
          pos2 (cdr (bounds-of-thing-at-point 'symbol))))

  ; now, pos1 and pos2 are the starting and ending positions
  ; of the current word, or current text selection if exists

  ;; put your code here.
  $0
  ;; Some example of things you might want to do
  (downcase-region pos1 pos2) ; example of a func that takes region as args
  (setq meat (buffer-substring-no-properties pos1 pos2)) ; grab the text.
  (delete-region pos1 pos2) ; get rid of it
  (insert "newText") ; insert your new text

  )
)
#+END_SRC
**** word_regexp
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: word_regexp
# key: <
# --
"\\_<${1:word}\\_>"
#+END_SRC
**** x-dired.process_marked
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: process marked files in dired
# key: x-dired
# --
;; idiom for processing a list of files in dired's marked files

;; suppose myProcessFile is your function that takes a file path
;; and do some processing on the file

(defun dired-myProcessFile ()
  "apply myProcessFile function to marked files in dired."
  (interactive)
  (require 'dired)
  (mapc 'myProcessFile (dired-get-marked-files))
)

;; to use it, type M-x dired-myProcessFile
#+END_SRC
**** x-file.process
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: a function that process a file
# key: x-file
# --
(defun doThisFile (fpath)
  "Process the file at path FPATH ..."
  (let ()
    ;; create temp buffer without undo record or font lock. (more efficient)
    ;; first space in temp buff name is necessary
    (set-buffer (get-buffer-create " myTemp"))
    (insert-file-contents fpath nil nil nil t)

    ;; process it ...
    ;; (goto-char 0) ; move to begining of file's content (in case it was open)
    ;; ... do something here
    ;; (write-file fpath) ;; write back to the file

    (kill-buffer " myTemp")))
#+END_SRC
**** x-file.read-lines
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: read lines of a file
# key: x-file
# --
(defun read-lines (filePath)
  "Return a list of lines in FILEPATH."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string
     (buffer-string) "\n" t)))

;; process all lines
(mapc
 (lambda (aLine)
   (message aLine) ; do your stuff here
   )
 (read-lines "inputFilePath")
)
#+END_SRC
**** x-find-replace
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: find and replace on region
# key: x-find-replace
# --
(defun replace-html-chars-region (start end)
  "Replace “<” to “&lt;” and other chars in HTML.
This works on the current region."
  (interactive "r")
  (save-restriction
    (narrow-to-region start end)
    (goto-char (point-min))
    (while (search-forward "&" nil t) (replace-match "&amp;" nil t))
    (goto-char (point-min))
    (while (search-forward "<" nil t) (replace-match "&lt;" nil t))
    (goto-char (point-min))
    (while (search-forward ">" nil t) (replace-match "&gt;" nil t))
    )
  )
#+END_SRC
**** x-grabstring
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: grab buffer substring
# key: x-grabstring
# --
(setq $0 (buffer-substring-no-properties myStartPos myEndPos))
#+END_SRC
**** x-grabthing
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: grab word under cursor
# key: x-grabthing
# --
(setq $0 (thing-at-point 'symbol))
#+END_SRC
**** x-traverse_dir
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# name: traversing a directory
# contributor: Xah Lee (XahLee.org)
# key: x-traverse_dir
# --
;; apply a function to all files in a dir
(require 'find-lisp)
(mapc 'my-process-file (find-lisp-find-files "~/myweb/" "\\.html$"))
#+END_SRC
**** x-word-or-region
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: Command that works on region or word
# key: x-word-or-region
# --
;; example of a command that works on current word or text selection
(defun down-case-word-or-region ()
  "Lower case the current word or text selection."
(interactive)
(let (pos1 pos2 meat)
  (if (and transient-mark-mode mark-active)
      (setq pos1 (region-beginning)
            pos2 (region-end))
    (setq pos1 (car (bounds-of-thing-at-point 'symbol))
          pos2 (cdr (bounds-of-thing-at-point 'symbol))))

  ; now, pos1 and pos2 are the starting and ending positions
  ; of the current word, or current text selection if exists

  ;; put your code here.
  $0
  ;; Some example of things you might want to do
  (downcase-region pos1 pos2) ; example of a func that takes region as args
  (setq meat (buffer-substring-no-properties pos1 pos2)) ; grab the text.
  (delete-region pos1 pos2) ; get rid of it
  (insert "newText") ; insert your new text

  )
)
#+END_SRC
**** yes-or-no-p
#+BEGIN_SRC snippet
# -*- mode: snippet -*-
# contributor: Xah Lee (XahLee.org)
# name: yes-or-no-p
# key: yonp
# --
(yes-or-no-p "${1:prompt} ")
#+END_SRC
*** fish-mode/
**** bang
#+BEGIN_SRC snippet
# name: bang
# key: !
# --
#!/usr/bin/env fish
$0

#+END_SRC
**** block
#+BEGIN_SRC snippet
# name: begin ... end
# key: block
# --
begin
    $0
end

#+END_SRC
**** bp
#+BEGIN_SRC snippet
# name: breakpoint
# key: bp
# --
breakpoint
$0
#+END_SRC
**** for
#+BEGIN_SRC snippet
# name: for loop
# key: for
# --
for ${1:var} in ${2:stuff}
    $0
end

#+END_SRC
**** function
#+BEGIN_SRC snippet
# name: function
# key: function
# --
function ${1:name}
    $0
end

#+END_SRC
**** if
#+BEGIN_SRC snippet
# name: if ... end
# key: if
# --
if ${1:[ -f file ]}
    ${2:do}
end
$0
#+END_SRC
**** ife
#+BEGIN_SRC snippet
# name: if ... ... else ... end
# key: ife
# --
if ${1:cond}
    ${2:stuff}
else
    ${3:other}
end
$0

#+END_SRC
**** sw
#+BEGIN_SRC snippet
# name: switch
# key: sw
# --
switch ${1:condition}
    case ${2:*}
         ${0}
end

#+END_SRC
**** while
#+BEGIN_SRC snippet
# name: while loop
# key: while
# --
while ${1:cond}
    $0
end

#+END_SRC
*** fundamental-mode/
**** current-date
#+BEGIN_SRC snippet
# name: current-date
# key: dd
# contributor : Kristof Molnar-Tatai <kristof.mlnr@gmail.com>
# --
`(format-time-string "%Y-%m-%d")`
#+END_SRC
**** mode-line
#+BEGIN_SRC snippet
# name: Mode line
# key: -*-
# contributor : Daniel Hornung <d.hornung@indiscale.com>
# --
# -*- mode:${1:conf}; -*-
#+END_SRC
*** git-commit-mode/
**** .yas-parents
#+BEGIN_SRC snippet
text-mode
#+END_SRC
**** fixes
#+BEGIN_SRC snippet
# name: fixes
# key: fix
# --
fixes #${1:100}
#+END_SRC
**** references
#+BEGIN_SRC snippet
# name: references
# key: ref
# --
references #${1:100}
#+END_SRC
**** type
#+BEGIN_SRC snippet
# name: type
# key: type
# --
${1:$$(yas-choose-value '("fix" "hotfix" "add" "update" "change" "clean" "disable" "remove" "upgrade" "revert"))} $0
#+END_SRC
*** js-mode/
**** al
#+BEGIN_SRC snippet
# name: alert
# --
alert($0);
#+END_SRC
**** anfn
#+BEGIN_SRC snippet
# uuid: 289f0557-4e11-47c5-bcbf-1105bbec41ce
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: anonymousFunction
# key: anfn
# --

(${1:params}) => {
  ${2}
}
#+END_SRC
**** bnd
#+BEGIN_SRC snippet
# uuid: 6788dcb5-8d8e-4e30-a97b-83029ecaf89b
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: bindThis
# key: bnd
# --

this.${1:methodName} = this.${1:methodName}.bind(this)$0
#+END_SRC
**** class
#+BEGIN_SRC snippet
# name: class
# key: class
# --
class ${1:Class}${2: extends ${3:ParentClass}} {
  ${4:constructor(${5:arg}) {
    ${6:super(arg);}
    $7
  }}

  $0
}
#+END_SRC
**** cmmb
#+BEGIN_SRC snippet
# uuid: 983d648f-a7de-4e22-bab9-bca5cd6188a6
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: Comment Big Block
# key: cmmb
# --

/**
|--------------------------------------------------
| $1
|--------------------------------------------------
*/
#+END_SRC
**** com
#+BEGIN_SRC snippet
# name: comment (/* ... */)
# --
/*
 * $0
 */
#+END_SRC
**** const
#+BEGIN_SRC snippet
# name: const declaration
# key: const
# --
const ${1:name} = ${2:initial};
#+END_SRC
**** dar
#+BEGIN_SRC snippet
# uuid: 1867e4d6-1042-422e-b114-174969b9325e
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: destructingArray
# key: dar
# --

const [${1:propertyName}] = ${2:arrayToDestruct}
#+END_SRC
**** debugger
#+BEGIN_SRC snippet
# name: debugger
# key: dbg
# --
debugger;
#+END_SRC
**** dob
#+BEGIN_SRC snippet
# uuid: 0a552742-2fa3-4d23-8fe6-fe7f211b642a
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: destructingObject
# key: dob
# --

const {${1:propertyName}} = ${2:objectToDestruct}
#+END_SRC
**** each
#+BEGIN_SRC snippet
# name: each
# --
${1:collection}.forEach(function (${2:elem}) {
  $0
});
#+END_SRC
**** edf
#+BEGIN_SRC snippet
# uuid: 45f3a8b4-7ed0-4d80-aa77-1cf79339b6b6
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: exportDefaultFunction
# key: edf
# --

export default (${1:params}) => {
  $0
}
#+END_SRC
**** el
#+BEGIN_SRC snippet
# name: else
# --
else {
  $0
}
#+END_SRC
**** enf
#+BEGIN_SRC snippet
# uuid: 095f24bf-5c76-4d0b-862e-a1f0ab1e1b95
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: exportNamedFunction
# key: enf
# --

export const ${1:functionName} = (${2:params}) => {
  $0
}
#+END_SRC
**** exa
#+BEGIN_SRC snippet
# uuid: 1391f808-8044-4878-b551-9f129330507c
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: exportAs
# key: exa
# --

export { ${2:originalName} as ${3:alias} } from '${1:module}'$0
#+END_SRC
**** exd
#+BEGIN_SRC snippet
# uuid: b9a77d53-af00-4acc-90e5-0259edef0326
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: exportDestructing
# key: exd
# --

export { $2 } from '${1:module}'$0
#+END_SRC
**** exp
#+BEGIN_SRC snippet
# uuid: 19643fe0-3063-41cd-b384-9f0a51b2f809
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: exportDefault
# key: exp
# --

export default $1$0
#+END_SRC
**** fin
#+BEGIN_SRC snippet
# uuid: 8d343f0b-28ae-4e2c-84a4-2e557603f28b
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: forIn
# key: fin
# --

for(let ${1:item} in ${2:object}) {
  ${0}
}
#+END_SRC
**** flow
#+BEGIN_SRC snippet
# name: /* @flow */
# key: flow
# --
/* @flow */
#+END_SRC
**** fof
#+BEGIN_SRC snippet
# uuid: eec73b34-fb19-4d4c-b4fd-853b2eca6f19
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: forOf
# key: fof
# --

for(let ${1:item} of ${2:object}) {
  ${0}
}
#+END_SRC
**** for
#+BEGIN_SRC snippet
# name: for
# --
for (var ${1:i} = ${2:0}; $1 < ${3:collection}.length; $1++) {
  $0
}
#+END_SRC
**** fre
#+BEGIN_SRC snippet
# uuid: a59f3383-a176-4f60-a992-0d2b983eaa5c
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: forEach
# key: fre
# --

${1:array}.forEach(${2:currentItem} => {
  ${0}
})
#+END_SRC
**** function
#+BEGIN_SRC snippet
# name: function
# key: f
# --
function ${1:name}(${2:arg}) {
         $0
}

#+END_SRC
**** if
#+BEGIN_SRC snippet
# name: if
# --
if (${1:condition}) {
  $0
}
#+END_SRC
**** ima
#+BEGIN_SRC snippet
# uuid: 7c3ddd59-68e7-456c-a906-4241cdaeaf9e
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: importAs
# key: ima
# --

import { ${2:originalName} as ${3:alias} } from '${1:module}'$0
#+END_SRC
**** imd
#+BEGIN_SRC snippet
# uuid: 851254b3-d70e-4024-a557-2629d3d73507
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: importDestructing
# key: imd
# --

import { $2 } from '${1:module}'$0
#+END_SRC
**** ime
#+BEGIN_SRC snippet
# uuid: 13efbfa8-12d3-4570-9602-6d64717d75e3
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: importEverything
# key: ime
# --

import * as ${2:alias} from '${1:module}'$0
#+END_SRC
**** imn
#+BEGIN_SRC snippet
# uuid: 39b0065c-1dd5-4214-a612-1fead18dd677
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: importNoModuleName
# key: imn
# --

import '${1:module}'$0
#+END_SRC
**** imp
#+BEGIN_SRC snippet
# uuid: fb07fe1d-4cf7-47e9-bca8-51a6438c5d6f
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: import
# key: imp
# --

import ${2:moduleName} from '${1:module}'$0
#+END_SRC
**** init
#+BEGIN_SRC snippet
# name: constructor
# key: init
# --
constructor(${1:arg}) {
  ${2:super(${3:arg});}
  $0
}
#+END_SRC
**** let
#+BEGIN_SRC snippet
# name: let declaration
# key: let
# --
let ${1:name} = ${2:initial};
#+END_SRC
**** met
#+BEGIN_SRC snippet
# name: method
# key: met
# --
${1:name}(${2:arg}) {
  $0
}
#+END_SRC
**** metb
#+BEGIN_SRC snippet
# uuid: b8f2656b-94d0-40fc-baf2-d335073ecd54
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: bound method
# key: metb
# --

${1:methodName} = (${2:params}) => {
  ${0}
}
#+END_SRC
**** multiline-comment
#+BEGIN_SRC snippet
# name: multiline-comment
# key: /**
# --
/**
 * $0
 */
#+END_SRC
**** nfn
#+BEGIN_SRC snippet
# uuid: 4650c619-bbd9-4496-955a-1d626fdf8bcb
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: namedFunction
# key: nfn
# --

const ${1:name} = (${2:params}) => {
  ${3}
}
#+END_SRC
**** param-comment
#+BEGIN_SRC snippet
  # name: param-comment
  # key: *@p
  #condition: (= (js2-node-type (js2-node-at-point)) js2-COMMENT)
  # --
  ,* @param {${type}} ${comment}.n
#+END_SRC
**** pge
#+BEGIN_SRC snippet
# uuid: 4d26710e-cad0-4584-8099-87403d4c43cb
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: propertyGet
# key: pge
# --

get ${1:propertyName}() {
  return this.${0}
}
#+END_SRC
**** prom
#+BEGIN_SRC snippet
# uuid: 1f2ca8a4-dda2-4b88-9377-23ec10760aec
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: promise
# key: prom
# --

return new Promise((resolve, reject) => {
  ${1}
})
#+END_SRC
**** pse
#+BEGIN_SRC snippet
# uuid: b33dbf56-f2ad-489e-bc7b-1b4c2d1657ea
# contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
# name: propertyset
# key: pse
# --

set ${1:propertyName}(${2:value}) {
  ${0}
}
#+END_SRC
**** return-comment
#+BEGIN_SRC snippet
  # name: return-comment
  # key: *@r
  #condition: (= (js2-node-type (js2-node-at-point)) js2-COMMENT)
  # --
  ,* @return {${type}}
#+END_SRC
**** sti
#+BEGIN_SRC snippet
  # uuid: 596c0e05-ee02-4d02-85e0-64252296629d
  # contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
  # name: setInterval
  # key: sti
  # --

  setInterval(() => {
    ${2}
  }, ${0:intervalInms})
#+END_SRC
**** sto
#+BEGIN_SRC snippet
  # uuid: 6ead1d1a-bf84-4a3d-94fb-59ad97d55414
  # contributor: Jimmy Yuen Ho Wong <wyuenho@gmail.com>
  # name: setTimeOut
  # key: sto
  # --

  setTimeout(() => {
    ${2}
  }, ${1:delayInms})
#+END_SRC
**** switch
#+BEGIN_SRC snippet
  # name: switch
  # key: sw
  # --
  switch (${1:condition}) {
    case ${2:expression}:
      $0
      break;
    default:
  }
#+END_SRC
**** try-catch
#+BEGIN_SRC snippet
  # name: try...catch statement
  # key: try
  # --
  try {
    $1
  } catch (err) {
    $2
  }${3: finally {
    $4
  }}
#+END_SRC
**** type-inline-comment
#+BEGIN_SRC snippet
  # name: type-inline-comment
  # key: @ty
  #condition: (not (= (js2-node-type (js2-node-at-point)) js2-COMMENT))
  # --
  /** @type {${type}} */
#+END_SRC
**** type-multiline-comment
#+BEGIN_SRC snippet
  # name: type-inline-comment
  # key: *ty
  #condition: (= (js2-node-type (js2-node-at-point)) js2-COMMENT)
  # --
  ,* @type {${type}}
#+END_SRC
*** js2-mode/
**** .yas-parents
#+BEGIN_SRC snippet
js-mode

#+END_SRC
*** js3-mode/
**** .yas-parents
#+BEGIN_SRC snippet
js-mode

#+END_SRC
*** lisp-interaction-mode/
**** defun
#+BEGIN_SRC snippet
# name: defun
# key: defun
# --
(defun ${1:fun} (${2:args})
       $0
)
#+END_SRC
*** lisp-mode/
**** class
#+BEGIN_SRC snippet
# name: class
# key: cls
# --
(defclass ${1:name} (${2:inherits})
   (${4:slot})
   (:documentation "${3:doc}"))
$0
#+END_SRC
**** comment
#+BEGIN_SRC snippet
# name: comment
# key: /*
# --
#|${1:type the comment here}|#
$0
#+END_SRC
**** cond
#+BEGIN_SRC snippet
# name: cond
# key: cond
# --
(cond (${1:case1} (${2:do-this}))
      (${3:case2} (${4:do-this}))
      (t ${5:default}))
$0
#+END_SRC
**** defpackage
#+BEGIN_SRC snippet
# name: defpackage
# key: defp
# --
(defpackage #:${1:name}
   (:nicknames #:${2:nick})
   (:use #:cl #:closer-mop #:${3:package})
   (:shadow :${4.symbol})
   (:shadowing-import-from #:${5:package} #:${6:symbol})
   (:export :$0))
#+END_SRC
**** do
#+BEGIN_SRC snippet
# name: do
# key: do
# --
(do ((${1:var1} ${2:init-form} ${3:step-form})
     (${4:var2} ${5:init-form} ${6:step-form}))
    (${7:condition} ${8:return-value})
    (${9:body}))
$0
#+END_SRC
**** for
#+BEGIN_SRC snippet
# name: do
# key: for
# --
(dotimes (${1:var} ${2:count-form})
         ${3:body})
$0
#+END_SRC
**** foreach
#+BEGIN_SRC snippet
# name: do
# key: foreach
# --
(dolist (${1:var} ${2:list-form})
        ${3:body})
$0
#+END_SRC
**** format
#+BEGIN_SRC snippet
# name: format
# key: print
# --
(format t "~& $0 ~%")
#+END_SRC
**** if
#+BEGIN_SRC snippet
# name: if
# key: if
# --
(when (${1:condition})
      (${2:then-do-this}))
$0
#+END_SRC
**** ifelse
#+BEGIN_SRC snippet
# name: ifelse (...) (...) (...) ...
# key: ifelse
# --
(if (${1:condition})
    (${2:then})
    (${3:else}))
$0
#+END_SRC
**** ifnot
#+BEGIN_SRC snippet
# name: ifnot (...) (...)  ...
# key: ifnot
# --
(unless (${1:condition})
        (${2:then-do-this}))
$0
#+END_SRC
**** slot
#+BEGIN_SRC snippet
# name: slot
# key: slot
# --
(${1:name} :initarg :${1:$(yas/substr yas-text "[^: ]*")}
           :initform (error ":${1:$(yas/substr yas-text "[^: ]*")} must be specified")
           ;; :accessor ${1:$(yas/substr yas-text "[^: ]*")}
           :reader ${1:$(yas/substr yas-text "[^: ]*")}-changed
           :writer set-${1:$(yas/substr yas-text "[^: ]*")}
           :type
           :allocation ${3::class :instance}
           :documentation "${2:about-slot}")
$0
#+END_SRC
**** typecast
#+BEGIN_SRC snippet
# name: typecast
# name: cast
# --
(coerce ${1:object} ${2:type})
$0
#+END_SRC
*** makefile-mode/
**** all
     #+BEGIN_SRC snippet
       # name: all
       # key: all
       # --
       .PHONY: all
       all:
               $0
     #+END_SRC
**** phony
     #+BEGIN_SRC snippet
       # name: phony
       # --
       .PHONY: $1
       $1:
               ${1:rm -r ${2:\$(${3:OUTDIR})}}
               $0
     #+END_SRC
*** markdown-mode/
**** back-quote
#+BEGIN_SRC snippet
# name: Inline Code
# contributor: Peng Deng <dengpeng@gmail.com>
# key: `
# --
\`${1:Code}\` $0
#+END_SRC
**** code
#+BEGIN_SRC snippet
# name: Code block
# key: code
# --
\`\`\`$1
$0
\`\`\`
#+END_SRC
**** emphasis
#+BEGIN_SRC snippet
# name: Emphasis
# contributor: Peng Deng <dengpeng@gmail.com>
# key: _
# --
_${1:Text}_ $0
#+END_SRC
**** h1.1
#+BEGIN_SRC snippet
# name: Header 1 (#)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h1
# --
# ${1:Header 1} #
$0
#+END_SRC
**** h1.2
#+BEGIN_SRC snippet
# name: Header 1 (=)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h1
# --
${1:Header 1}
${1:$(make-string (string-width yas-text) ?\=)}
$0
#+END_SRC
**** h2.1
#+BEGIN_SRC snippet
# name: Header 2 (##)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h2
# --
## ${1:Header 1} ##
$0
#+END_SRC
**** h2.2
#+BEGIN_SRC snippet
# name: Header 2 (-)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h2
# --
${1:Header 2}
${1:$(make-string (string-width yas-text) ?\-)}
$0
#+END_SRC
**** h3
#+BEGIN_SRC snippet
# name: Header 3
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h3
# --
### ${1:Header 3} ###
$0
#+END_SRC
**** h4
#+BEGIN_SRC snippet
# name: Header 4
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h4
# --
#### ${1:Header 4} ####
$0
#+END_SRC
**** h5
#+BEGIN_SRC snippet
# name: Header 5
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h5
# --
##### ${1:Header 5} #####
$0
#+END_SRC
**** h6
#+BEGIN_SRC snippet
# name: Header 6
# contributor: Peng Deng <dengpeng@gmail.com>
# key: h6
# --
###### ${1:Header 6} ######
$0
#+END_SRC
**** highlight
#+BEGIN_SRC snippet
# name: Highlight
# contributor: nguyenvinhlinh <nguyenvinhlinh93@gmail.com>
# key: highlight
# --
{% highlight ${1:language} %}
${0:content}
{% endhighlight %}
#+END_SRC
**** hr.1
#+BEGIN_SRC snippet
# name: Horizontal Rule (-)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: hr
# --
----------
$0
#+END_SRC
**** hr.2
#+BEGIN_SRC snippet
# name: Horizontal Rule (*)
# contributor: Peng Deng <dengpeng@gmail.com>
# key: hr
# --
*******
$0
#+END_SRC
**** hyphen
#+BEGIN_SRC snippet
# name: Unordered List
# contributor: Peng Deng <dengpeng@gmail.com>
# key: -
# --
- ${1:Text}
- $0
#+END_SRC
**** img
#+BEGIN_SRC snippet
# name: Image
# contributor: Peng Deng <dengpeng@gmail.com>
# key: img
# --
![${1:Alt Text}](${2:URL} $3) $0
#+END_SRC
**** link
#+BEGIN_SRC snippet
# name: Link
# contributor: Peng Deng <dengpeng@gmail.com>
# key: link
# --
[${1:Link Text}](${2:URL} $3) $0
#+END_SRC
**** ordered-list
#+BEGIN_SRC snippet
# name: Ordered List
# contributor: Peng Deng <dengpeng@gmail.com>
# key: ol
# --
${1:1}. ${2:Text}
${1:$(number-to-string (1+ (string-to-number yas-text)))}. $0
#+END_SRC
**** plus
#+BEGIN_SRC snippet
# name: Unordered List
# contributor: Peng Deng <dengpeng@gmail.com>
# key: +
# --
+ ${1:Text}
+$0
#+END_SRC
**** rimg
#+BEGIN_SRC snippet
# name: Referenced Image
# contributor: Peng Deng <dengpeng@gmail.com>
# key: rimg
# --
![${1:Alt Text}][$2] $0
#+END_SRC
**** rlb
#+BEGIN_SRC snippet
# name: Reference Label
# contributor: Peng Deng <dengpeng@gmail.com>
# key: rlb
# --
[${1:Reference}]: ${2:URL} $3
$0
#+END_SRC
**** rlink
#+BEGIN_SRC snippet
# name: Reference Link
# contributor: Peng Deng <dengpeng@gmail.com>
# key: rlink
# --
[${1:Link Text}][$2] $0
#+END_SRC
**** strong-emphasis
#+BEGIN_SRC snippet
# name: Strong emphasis
# contributor: Peng Deng <dengpeng@gmail.com>
# key: __
# --
**${1:Text}** $0
#+END_SRC
**** utf8
#+BEGIN_SRC snippet
# name: UTF-8 encoding
# key: utf8
# contributor: Thiago Perrotta
# --
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
$0
#+END_SRC
*** org-mode/
**** atcoder
#+BEGIN_SRC snippet
  # name: atcoder
  # key: atcoder
  # --
  ,** ${1:name}
  ,*** definition
      ,#+name: $1
      ,#+BEGIN_SRC lisp :noweb yes
      ,#+END_SRC
  ,*** usage
      ,#+BEGIN_SRC lisp
      ,#+END_SRC
#+END_SRC
**** author
#+BEGIN_SRC snippet
# name: author
# key: <au
# --
#+author: $0
#+END_SRC
**** center
#+BEGIN_SRC snippet
# name: center
# key: <c
# --
#+begin_center
$0
#+end_center
#+END_SRC
**** date
#+BEGIN_SRC snippet
# name: date
# key: <da
# --
#+date: ${1:year}:${2:month}:${3:day}
#+END_SRC
**** description
#+BEGIN_SRC snippet
# name: description
# key: desc
# --
#+description: $0
#+END_SRC
**** dot
#+BEGIN_SRC snippet
# name: dot
# key: dot_
# --
#+begin_src dot :file ${1:file} :cmdline -t${2:pdf} :exports none :results silent
$0
#+end_src
[[file:${3:path}]]
#+END_SRC
**** email
#+BEGIN_SRC snippet
# name: email
# key: <em
# --
#+email: $0
#+END_SRC
**** embedded
#+BEGIN_SRC snippet
# name: embedded
# key: emb_
# --
src_${1:lang}${2:[${3:where}]}{${4:code}}
#+END_SRC
**** entry
#+BEGIN_SRC snippet
# name: entry
# key: entry_
# --
#+begin_html
---
layout: ${1:default}
title: ${2:title}
---
#+end_html
#+END_SRC
**** exampleblock
#+BEGIN_SRC snippet
# name: example
# key: <e
# --
#+begin_example
$0
#+end_example
#+END_SRC
**** export
#+BEGIN_SRC snippet
# name: export
# key: <ex
# --
#+begin_export ${1:type}
$0
#+end_export
#+END_SRC
**** figure
#+BEGIN_SRC snippet
# name: figure
# key: fig_
# --
#+caption: ${1:caption}
#+attr_latex: ${2:scale=0.75}
#+label: fig:${3:label}$0
#+END_SRC
**** html
#+BEGIN_SRC snippet
# name: html
# key: <ht
# --
#+html:$1
#+END_SRC
**** image
#+BEGIN_SRC snippet
# name: image
# key: <im
# --
#+caption: ${1:caption of the image}
[[file:${2:image_path}]]$0
#+END_SRC
**** img
#+BEGIN_SRC snippet
# name: img
# key: img_
# --
<img src="$1" alt="$2" align="${3:left}" title="${4:image title}" class="img" $5/>$0
#+END_SRC
**** include
#+BEGIN_SRC snippet
# name: include
# key: <i
# --
#+include: $0
#+END_SRC
**** keywords
#+BEGIN_SRC snippet
# name: keywords
# key: <ke
# --
#+keywords: $0
#+END_SRC
**** language
#+BEGIN_SRC snippet
# name: language
# key: <lan
# --
#+language: ${1:en}
#+END_SRC
**** link
#+BEGIN_SRC snippet
# name: link
# key: <li
# --
[[${1:link}][${2:description}]]
#+END_SRC
**** matrix
#+BEGIN_SRC snippet
# name: matrix
# key: matrix_
# possible improvement, compute the number of lines from the argument to array
# --
\left \(
\begin{array}{${1:ccc}}
${2:v1 & v2} \\
$0
\end{array}
\right \)
#+END_SRC
**** name_src
#+BEGIN_SRC snippet
# name: name_src
# key: name_src
# --
#+name:${2:name}
#+BEGIN_SRC ${1:emacs-lisp}
  $0
#+END_SRC
#+END_SRC
**** options
#+BEGIN_SRC snippet
# name: options
# key: <op
# --
#+options: h:${1:1} num:${2:t||nil} toc:${3:t||nil}$0
#+END_SRC
**** quote
#+BEGIN_SRC snippet
# name: quote
# key: <q
# --
#+begin_quote
$0
#+end_quote
#+END_SRC
**** rv_background
#+BEGIN_SRC snippet
# name: reveal_single_colored_background
# key: <rsb
# --
:properties:
:reveal_background: ${1: #123456}
:end:
#+END_SRC
**** rv_image_background
#+BEGIN_SRC snippet
# name: reveal_image_background
# key: <rib
# --
    :properties:
    :reveal_background: ${1: path of the image}
    :reveal_background_trans: ${2: default||cube||page||concave||zoom||linear||fade||none||slide}
    :end:
#+END_SRC
**** setup
#+BEGIN_SRC snippet
# name: setup
# key: set
# --
#+setupfile: $0
#+END_SRC
**** src
#+BEGIN_SRC snippet
# name: src
# key: <src
# --
#+BEGIN_SRC $1
  $0
#+END_SRC
#+END_SRC
**** src_noweb
#+BEGIN_SRC snippet
# name: src_noweb
# key: src_noweb
# --
#+BEGIN_SRC ${1:emacs-lisp} :noweb yes
  $0
#+END_SRC
#+END_SRC
**** style
#+BEGIN_SRC snippet
# name: style
# key: <st
# --
#+style: <link rel="stylesheet" type="text/css" href="$1" />
#+END_SRC
**** table
#+BEGIN_SRC snippet
# name: table
# key: <ta
# --
#+caption: ${1: caption of the table}
|${2:column 1} | ${3: column 2} |
|--------------+----------------|
#+END_SRC
**** title
#+BEGIN_SRC snippet
# name: title
# key: <ti
# --
#+title: $0
#+END_SRC
**** uml
#+BEGIN_SRC snippet
# name: uml
# key: uml
# contributor : Robert O'Connor
# --
#+begin_uml
$1
#+end_uml
#+END_SRC
**** verse
#+BEGIN_SRC snippet
# name: verse
# key: <v
# --
#+begin_verse
$0
#+end_verse
#+END_SRC
**** video
#+BEGIN_SRC snippet
# name: video
# key: <vi
# --
[[${1:link of the video}][file:${2:link of the image}]
#+END_SRC
*** prog-mode/
**** .yas-setup.el
#+BEGIN_SRC snippet
(require 'yasnippet)
;; whitespace removing functions from Magnar Sveen ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun yas-s-trim-left (s)
  "Remove whitespace at the beginning of S."
  (if (string-match "\\`[ \t\n\r]+" s)
      (replace-match "" t t s)
    s))
(defun yas-s-trim-right (s)
  "Remove whitespace at the end of S."
  (if (string-match "[ \t\n\r]+\\'" s)
      (replace-match "" t t s)
    s))
(defun yas-s-trim (s)
  "Remove whitespace at the beginning and end of S."
  (yas-s-trim-left (yas-s-trim-right s)))
(defun yas-string-reverse (str)
  "Reverse a string STR manually to be compatible with emacs versions < 25."
  (apply #'string
         (reverse
          (string-to-list str))))
(defun yas-trimmed-comment-start ()
  "This function returns `comment-start' trimmed by whitespaces."
  (yas-s-trim comment-start))
(defun yas-trimmed-comment-end ()
  "This function returns `comment-end' trimmed by whitespaces if `comment-end' is not empty.
Otherwise the reversed output of function `yas-trimmed-comment-start' is returned."
  (if (eq (length comment-end) 0)
      (yas-string-reverse (yas-trimmed-comment-start))
    (yas-s-trim comment-end)))
#+END_SRC
**** comment
#+BEGIN_SRC snippet
# contributor: sh-ow <sh-ow@users.noreply.github.com>
# name: comment
# key: co
# --
`(yas-trimmed-comment-start)` ${1:comment}`(unless (eq (length comment-end) 0) (concat " " (yas-trimmed-comment-end)))`$0
#+END_SRC
**** commentblock
#+BEGIN_SRC snippet
# contributor: sh-ow <sh-ow@users.noreply.github.com>
# name: commentblock
# key: cob
# --
${1:$(let* ((col (current-column))
           (str "")
           (lastcom (substring (yas-trimmed-comment-start) -1))
           (start (yas-trimmed-comment-start))
           (end (yas-trimmed-comment-end))
           (over (- (+ (string-width yas-text) (length start) (length end) col) 77)))
         (while (< (length str) (+ (- 79 (length start) (length end) col) (if (> over 0) over 0)))
                (setq str (concat str lastcom)))
       (concat start str end))}
${1:$(let* ((col (current-column))
           (str "")
           (start (yas-trimmed-comment-start))
           (end (yas-trimmed-comment-end)))
         (while (< (length str) (ffloor (/ (- 78.0 (+ col (length start) (string-width yas-text) (length end))) 2.0)))
                (setq str (concat str " ")))
        (concat start str))} ${1:comment} ${1:$(let* ((col (current-column))
                                                     (str "")
                                                     (start (yas-trimmed-comment-start))
                                                     (end (yas-trimmed-comment-end)))
                                                   (while (< (length str) (- 79.0 (if (eq (mod (string-width yas-text) 2) 1) (- col 1) col) (length end)))
                                                          (setq str (concat str " ")))
                                                 (concat str end))}
${1:$(let* ((col (current-column))
           (str "")
           (lastcom (substring (yas-trimmed-comment-start) -1))
           (start (yas-trimmed-comment-start))
           (end (yas-trimmed-comment-end))
           (over (- (+ (string-width yas-text) (length start) (length end) col) 77)))
         (while (< (length str) (+ (- 79 (length start) (length end) col) (if (> over 0) over 0)))
                (setq str (concat str lastcom)))
       (concat start str end))}$0
#+END_SRC
**** commentline
#+BEGIN_SRC snippet
# contributor: sh-ow <sh-ow@users.noreply.github.com>
# name: commentline
# key: col
# --
`(yas-trimmed-comment-start)` ${1:comment} ${1:$(let* ((start (yas-trimmed-comment-start))
                                                       (lastcom (aref start (1- (length start))))
                                                       (end (yas-trimmed-comment-end))
                                                       (endpadlen (- 79 (+ (current-column) (length end)))))
                                              (concat (make-string (max endpadlen 0) lastcom)
                                                      end))}$0
#+END_SRC
**** fixme
#+BEGIN_SRC snippet
# name: fixme
# key: fi
# condition: (not (eq major-mode 'sh-mode))
# --
`comment-start`FIXME: $0`comment-end`
#+END_SRC
**** todo
#+BEGIN_SRC snippet
# name: todo
# key: t
# --
`comment-start`TODO: $0`comment-end`
#+END_SRC
**** xxx
#+BEGIN_SRC snippet
# name: xxx
# key: x
# --
`comment-start`XXX: $0`comment-end`
#+END_SRC
*** ruby-mode/
**** #
#+BEGIN_SRC snippet
# name: # =>
# group : general
# --
# =>
#+END_SRC
**** =b
#+BEGIN_SRC snippet
# name: =begin rdoc ... =end
# group : general
# --
=begin rdoc
  $0
=end
#+END_SRC
**** Comp
#+BEGIN_SRC snippet
# name: include Comparable; def <=> ... end
# group : definitions
# --
include Comparable
def <=> other
  $0
end
#+END_SRC
**** Enum
#+BEGIN_SRC snippet
# name: include Enumerable
# key: Enum
# group: collections
# --
include Enumerable
def each${1:(&block)}
  $0
end
#+END_SRC
**** GLOB
#+BEGIN_SRC snippet
# name: GLOB
# key: $
# --
$${1:GLOBAL} = $0
#+END_SRC
**** all
#+BEGIN_SRC snippet
# name: all? { |...| ... }
# group : collections
# --
all? { |${e}| $0 }
#+END_SRC
**** am
#+BEGIN_SRC snippet
# name: alias_method new, old
# group : definitions
# --
alias_method :${new_name}, :${old_name}
#+END_SRC
**** any
#+BEGIN_SRC snippet
# name: any? { |...| ... }
# group : collections
# --
any? { |${e}| $0 }
#+END_SRC
**** app
#+BEGIN_SRC snippet
# name: if __FILE__ == $PROGRAM_NAME ... end
# group : general
# --
if __FILE__ == $PROGRAM_NAME
  $0
end
#+END_SRC
**** attribute
#+BEGIN_SRC snippet
# name: attribute
# key: @
# --
@${1:attr} = $0
#+END_SRC
**** bench
#+BEGIN_SRC snippet
# name: bench
# key: bench
# --
require "benchmark"
TESTS = ${1:1_000}
Benchmark.bmbm do |x|
  x.report("${2:var}") {}
end
#+END_SRC
**** bm
#+BEGIN_SRC snippet
# name: Benchmark.bmbm(...) do ... end
# group : general
# --
Benchmark.bmbm(${1:10}) do |x|
  $0
end
#+END_SRC
**** case
#+BEGIN_SRC snippet
# name: case ... end
# group : general
# --
case ${1:object}
when ${2:condition}
  $0
end
#+END_SRC
**** cla
#+BEGIN_SRC snippet
# name: class << self ... end
# group : definitions
# --
class << ${self}
  $0
end
#+END_SRC
**** cls
#+BEGIN_SRC snippet
# name: class ... end
# contributor : hitesh <hitesh.jasani@gmail.com>
# group : definitions
# --
class ${1:`(let ((fn (capitalize (file-name-nondirectory
                                 (file-name-sans-extension
				 (or (buffer-file-name)
				     (buffer-name (current-buffer))))))))
             (replace-regexp-in-string "_" "" fn t t))`}
  $0
end
#+END_SRC
**** collect
#+BEGIN_SRC snippet
# name: collect { |...| ... }
# group : collections
# --
collect { |${e}| $0 }
#+END_SRC
**** dee
#+BEGIN_SRC snippet
# name: deep_copy(...)
# group : general
# --
Marshal.load(Marshal.dump($0))
#+END_SRC
**** def
#+BEGIN_SRC snippet
# name: def ... end
# key: def
# --
def ${1:method}${2:(${3:args})}
    $0
end
#+END_SRC
**** deli
#+BEGIN_SRC snippet
# name: delete_if { |...| ... }
# group : collections
# --
delete_if { |${e}| $0 }
#+END_SRC
**** det
#+BEGIN_SRC snippet
# name: detect { |...| ... }
# group : collections
# --
detect { |${e}| $0 }
#+END_SRC
**** dow
#+BEGIN_SRC snippet
# name: downto(...) { |n| ... }
# group : control structure
# --
downto(${0}) { |${n}|
  $0
}
#+END_SRC
**** ea
#+BEGIN_SRC snippet
# name: each { |...| ... }
# group : collections
# --
each { |${e}| $0 }
#+END_SRC
**** eac
#+BEGIN_SRC snippet
# name: each_cons(...) { |...| ... }
# group : collections
# --
each_cons(${1:2}) { |${group}| $0 }
#+END_SRC
**** eai
#+BEGIN_SRC snippet
# name: each_index { |i| ... }
# group : collections
# --
each_index { |${i}| $0 }
#+END_SRC
**** eav
#+BEGIN_SRC snippet
# name: each_value { |val| ... }
# group : collections
# --
each_value { |${val}| $0 }
#+END_SRC
**** eawi
#+BEGIN_SRC snippet
# name: each_with_index { |e, i| ... }
# group : collections
# --
each_with_index { |${e}, ${i}| $0 }
#+END_SRC
**** for
#+BEGIN_SRC snippet
# name: for
# key: for
# --
for ${1:el} in ${2:collection}
    $0
end
#+END_SRC
**** forin
#+BEGIN_SRC snippet
# name: for ... in ...; ... end
# group : control structure
# --
for ${1:element} in ${2:collection}
  $0
end
#+END_SRC
**** formula
#+BEGIN_SRC snippet
# name: formula
# key: form
# --
require 'formula'
class ${1:Name} <Formula
  url '${2:url}'
  homepage '${3:home}'
  md5 '${4:md5}'
  def install
    ${5:system "./configure"}
    $0
  end
end
#+END_SRC
**** if
#+BEGIN_SRC snippet
# name: if ... end
# group : control structure
# --
if ${1:condition}
  $0
end
#+END_SRC
**** ife
#+BEGIN_SRC snippet
# name: if ... else ... end
# group : control structure
# --
if ${1:condition}
  $2
else
  $3
end
#+END_SRC
**** inc
#+BEGIN_SRC snippet
# name: include Module
# key: inc
# group: general
# --
include ${1:Module}
$0
#+END_SRC
**** init
#+BEGIN_SRC snippet
# name: init
# key: init
# --
def initialize(${1:args})
    $0
end
#+END_SRC
**** inject
#+BEGIN_SRC snippet
# name: inject(...) { |...| ... }
# group : collections
# --
inject(${1:0}) { |${2:injection}, ${3:element}| $0 }
#+END_SRC
**** map
#+BEGIN_SRC snippet
# name: map { |...| ... }
# group : collections
# --
map { |${e}| $0 }
#+END_SRC
**** mm
#+BEGIN_SRC snippet
# name: def method_missing ... end
# group : definitions
# --
def method_missing(method, *args)
  $0
end
#+END_SRC
**** mod
#+BEGIN_SRC snippet
# name: module ... end
# contributor: hitesh <hitesh.jasani@gmail.com>, jimeh <contact@jimeh.me>
# key: mod
# --
module ${1:`(let ((fn (capitalize (file-name-nondirectory
                                 (file-name-sans-extension
         (or (buffer-file-name)
             (buffer-name (current-buffer))))))))
           (while (string-match "_" fn)
             (setq fn (replace-match "" nil nil fn)))
           fn)`}
  $0
end
#+END_SRC
**** proc
#+BEGIN_SRC snippet
# name: Proc.new { |...| ... }
# key: proc
# contributor: Valery Zajkov
# --
Proc.new { |${1:argument}| $0 }
#+END_SRC
**** pry
#+BEGIN_SRC snippet
# name: binding.pry
# key: pry
# --
require 'pry'; binding.pry
#+END_SRC
**** r
#+BEGIN_SRC snippet
# name: attr_reader ...
# group : definitions
# --
attr_reader :
#+END_SRC
**** rb
#+BEGIN_SRC snippet
# name: /usr/bin/ruby -wU
# group : general
# --
#!/usr/bin/ruby -wU
#+END_SRC
**** red
#+BEGIN_SRC snippet
# name: reduce(...) { |...| ... }
# group : collections
# --
reduce(${1:0}) { |${2:accumulator}, ${3:element}| $0 }
#+END_SRC
**** reject
#+BEGIN_SRC snippet
# name: reject { |...| ... }
# group : collections
# --
reject { |${1:element}| $0 }
#+END_SRC
**** rel
#+BEGIN_SRC snippet
# name: require_relative
# group : general
# --
require_relative '$0'
#+END_SRC
**** req
#+BEGIN_SRC snippet
# name: require "..."
# group : general
# --
require '$0'
#+END_SRC
**** rpry
#+BEGIN_SRC snippet
# name: binding.pry_remote
# key: rpry
# --
require 'pry-remote'; binding.remote_pry
#+END_SRC
**** rw
#+BEGIN_SRC snippet
# name: attr_accessor ...
# group : definitions
# --
attr_accessor :
#+END_SRC
**** select
#+BEGIN_SRC snippet
# name: select { |...| ... }
# group : collections
# --
select { |${1:element}| $0 }
#+END_SRC
**** str
#+BEGIN_SRC snippet
# name: str
# key: s
# --
#{$0}
#+END_SRC
**** test class
#+BEGIN_SRC snippet
# name: test class
# key: tc
# --
class TC_${1:Class} < Test::Unit::TestCase
      $0
end
#+END_SRC
**** tim
#+BEGIN_SRC snippet
# name: times { |n| ... }
# group : control structure
# --
times { |${n}| $0 }
#+END_SRC
**** to_
#+BEGIN_SRC snippet
# name: to_
# key: to_
# --
def to_s
    "${1:string}"
end
$0
#+END_SRC
**** tu
#+BEGIN_SRC snippet
# name: tu
# key: tu
# --
require 'test/unit'
#+END_SRC
**** unless
#+BEGIN_SRC snippet
# name: unless ... end
# group: control structure
# key: unless
# contributor: Valery Zajkov
# --
unless ${1:condition}
  $0
end
#+END_SRC
**** until
#+BEGIN_SRC snippet
# name: until ... end
# group: control structure
# --
until ${condition}
  $0
end
#+END_SRC
**** upt
#+BEGIN_SRC snippet
# name: upto(...) { |n| ... }
# group : control structure
# --
upto(${n}) { |${i}|
  $0
}
#+END_SRC
**** w
#+BEGIN_SRC snippet
# name: attr_writer ...
# group : definitions
# --
attr_writer :
#+END_SRC
**** when
#+BEGIN_SRC snippet
# name: when ... end
# group : control structure
# --
when ${condition}
  $0
end
#+END_SRC
**** while
#+BEGIN_SRC snippet
# name: while ... end
# group : control structure
# --
while ${condition}
  $0
end
#+END_SRC
**** y
#+BEGIN_SRC snippet
# name: :yields: arguments (rdoc)
# group : general
# --
:yields: $0
#+END_SRC
**** zip
#+BEGIN_SRC snippet
# name: zip(...) { |...| ... }
# group : collections
# --
zip(${enums}) { |${row}| $0 }
#+END_SRC
*** rust-mode/
**** allow
#+BEGIN_SRC snippet
# name: #[allow(lint)]
# key: allow
# --
#[allow(${1:lint})]
#+END_SRC
**** allow!
#+BEGIN_SRC snippet
# name: #![allow(lint)]
# key: allow!
# --
#![allow(${1:lint})]
#+END_SRC
**** assert
#+BEGIN_SRC snippet
# name: assert!(predicate);
# key: ass
# --
assert!(${1:predicate});
#+END_SRC
**** asserteq
#+BEGIN_SRC snippet
# name: assert_eq!(expected, actual);
# key: asseq
# --
assert_eq!(${1:expected}, ${2:actual});
#+END_SRC
**** case
#+BEGIN_SRC snippet
# name: pattern => expression,
# key: case
# --
${1:pattern} => ${2:expression},
#+END_SRC
**** cfg
#+BEGIN_SRC snippet
# name: #[cfg(option)]
# key: cfg
# --
#[cfg(${1:option})]
#+END_SRC
**** cfg=
#+BEGIN_SRC snippet
# name: #[cfg(option = "value")]
# key: cfg=
# --
#[cfg(${1:option} = "${2:value}")]
#+END_SRC
**** closure
#+BEGIN_SRC snippet
# name: closure
# key: ||
# --
|${1:arguments}| {
       $0
}
#+END_SRC
**** crate
#+BEGIN_SRC snippet
# name: extern crate
# key: ec
# --
extern crate ${1:name};
#+END_SRC
**** deny
#+BEGIN_SRC snippet
# name: #[deny(lint)]
# key: deny
# --
#[deny(${1:lint})]
#+END_SRC
**** deny!
#+BEGIN_SRC snippet
# name: #![deny(lint)]
# key: deny!
# --
#![deny(${1:lint})]
#+END_SRC
**** derive
#+BEGIN_SRC snippet
# name: #[derive(Trait)]
# key: derive
# --
#[derive(${1:Trait})]
#+END_SRC
**** display
#+BEGIN_SRC snippet
# name: impl Display for Type { fn fmt (...) }
# key: display
# --
impl Display for ${1:Type} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "$0")
    }
}
#+END_SRC
**** drop
#+BEGIN_SRC snippet
# name: impl Drop for Type { fn drop(...) }
# key: drop
# --
impl Drop for ${1:Type} {
     fn drop(&mut self) {
          $0
      }
}
#+END_SRC
**** enum
#+BEGIN_SRC snippet
# name: enum Type { ... }
# key: enum
# --
enum ${1:Type} {
     $0
}
#+END_SRC
**** eprint
#+BEGIN_SRC snippet
# name: eprint!("{}", value);
# key: eprint
# --
eprint!("${1:{\}}", $2);
#+END_SRC
**** eprintln
#+BEGIN_SRC snippet
# name: eprintln!("{}", value);
# key: eprintln
# --
eprintln!("${1:{\}}", $2);
#+END_SRC
**** fn
#+BEGIN_SRC snippet
# name: fn name() { ... }
# key: fn
# --
fn ${1:name}($2) {
    $0
}
#+END_SRC
**** fnr
#+BEGIN_SRC snippet
# name: fn name() -> Type { ... }
# key: fnr
# --
fn ${1:name}($2) -> ${3:Type} {
     $0
}
#+END_SRC
**** fns
#+BEGIN_SRC snippet
# name: fn name(&self) -> Type  { ... }
# key: fns
# --
fn ${1:name}(${2:&self}) -> ${3:Type}  {
    $0
}
#+END_SRC
**** fnw
#+BEGIN_SRC snippet
# name: fn name<T>(x: T) where T: Clone { ... }
# key: fnw
# --
fn ${1:name}<${2:T}>(${3:x: T}) where ${4:T: Clone} {
     $0
}
#+END_SRC
**** for
#+BEGIN_SRC snippet
# name: for var in iterable { ... }
# key: for
# --
for ${1:var} in ${2:iterable} {
    $0
}
#+END_SRC
**** from
#+BEGIN_SRC snippet
# name: impl From<From> for Type { fn from(...) }
# key: from
# --
impl From<${1:From}> for ${2:Type} {
    fn from(source: $1) -> Self {
       $0
       Self { }
    }
}
#+END_SRC
**** fromstr
#+BEGIN_SRC snippet
# name: impl FromStr for Type { fn from_str(...) }
# key: fromstr
# --
impl FromStr for ${1:Type} {
    type Err = ${2:Error};
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self{})
    }
}
#+END_SRC
**** if
#+BEGIN_SRC snippet
# name: if expr { ... }
# key: if
# --
if ${1:expression} {
    $0
}
#+END_SRC
**** ife
#+BEGIN_SRC snippet
# name: if expression { ... } else { .. }
# key: ife
# --
if ${1:expression} {
   $0
} else {
}
#+END_SRC
**** ifl
#+BEGIN_SRC snippet
# name: if let pattern = expression { ... };
# key: ifl
# --
if let ${1:pattern} = ${2:expression} {
    $0
};
#+END_SRC
**** impl
#+BEGIN_SRC snippet
# name: impl Type { ... }
# key: impl
# --
impl ${1:Type} {
     $0
}
#+END_SRC
**** implt
#+BEGIN_SRC snippet
# name: impl Trait for Type { ... }
# key: implt
# --
impl ${1:Trait} for ${2:Type} {
     $0
}
#+END_SRC
**** let
#+BEGIN_SRC snippet
# name: let pattern = expression;
# key: let
# --
let ${1:pattern} = ${2:expression};
#+END_SRC
**** letm
#+BEGIN_SRC snippet
# name: let mut pattern = expression;
# key: letm
# --
let mut ${1:pattern} = ${2:expression};
#+END_SRC
**** lett
#+BEGIN_SRC snippet
# name: let pattern: type = expression;
# key: lett
# --
let ${1:pattern}: ${2:type} = ${3:expression};
#+END_SRC
**** lettm
#+BEGIN_SRC snippet
# name: let mut pattern: type = expression;
# key: lettm
# --
let mut ${1:pattern}: ${2:type} = ${3:expression};
#+END_SRC
**** loop
#+BEGIN_SRC snippet
# name: loop { ... }
# key: loop
# --
loop {
     $0
}
#+END_SRC
**** macro
#+BEGIN_SRC snippet
# name: macro_rules! name { (..) => (..); }
# key: macro
# --
macro_rules! ${1:name} {
     ($2) => ($3);
}
#+END_SRC
**** main
#+BEGIN_SRC snippet
# name: fn main() { ... }
# key: main
# --
fn main() {
   $0
}
#+END_SRC
**** match
#+BEGIN_SRC snippet
# name: match expression { ... }
# key: match
# --
match ${1:expression} {
      $0
}
#+END_SRC
**** new
#+BEGIN_SRC snippet
# name: fn main() { ... }
# key: new
# --
pub fn new($1) -> ${2:Name} {
   $2 { ${3} }
}
#+END_SRC
**** pfn
#+BEGIN_SRC snippet
# name: pub fn name() { ... }
# key: pfn
# --
pub fn ${1:name}($2) {
    $0
}
#+END_SRC
**** pfnr
#+BEGIN_SRC snippet
# name: pub fn name() -> Type { ... }
# key: pfnr
# --
pub fn ${1:name}($2) -> ${3:Type} {
     $0
}
#+END_SRC
**** pfns
#+BEGIN_SRC snippet
# name: pub fn name(&self) -> Type  { ... }
# key: pfns
# --
pub fn ${1:name}(${2:&self}) -> ${3:Type} {
    $0
}
#+END_SRC
**** pfnw
#+BEGIN_SRC snippet
# name: pub fn name<T>(x: T) where T: Clone { ... }
# key: pfnw
# --
pub fn ${1:name}<${2:T}>(${3:x: T}) where ${4:T: Clone} {
     $0
}
#+END_SRC
**** print
#+BEGIN_SRC snippet
# name: print!("{}", value);
# key: print
# --
print!("${1:{\}}", $2);
#+END_SRC
**** println
#+BEGIN_SRC snippet
# name: println!("{}", value);
# key: println
# --
println!("${1:{\}}", $2);
#+END_SRC
**** result
#+BEGIN_SRC snippet
# name: Result<Type, failure::Error>
# key: result
# --
Result<${1:Type}, ${2:failure::Error}>
#+END_SRC
**** spawn
#+BEGIN_SRC snippet
# name: spawn(proc() { ... });
# key: spawn
# --
spawn(proc() {
      $0
});
#+END_SRC
**** static
#+BEGIN_SRC snippet
# name: CONSTANT: Type = value;
# key: static
# --
static ${1:CONSTANT}: ${2:Type} = ${3:value};
#+END_SRC
**** struct
#+BEGIN_SRC snippet
# name: struct TypeName { .. }
# key: struct
# --
struct ${1:TypeName} {
       $0
}
#+END_SRC
**** test
#+BEGIN_SRC snippet
# name: #[test] fn test_name() { .. }
# key: test
# --
#[test]
fn ${1:test_name}() {
   $0
}
#+END_SRC
**** testmod
#+BEGIN_SRC snippet
# name: test module
# key: testmod
# --
#[cfg(test)]
mod ${1:tests} {
    use super::*;
    #[test]
    fn ${2:test_name}() {
       $0
    }
}
#+END_SRC
**** trait
#+BEGIN_SRC snippet
# name: trait Type { ... }
# key: trait
# --
trait ${1:Type} {
      $0
}
#+END_SRC
**** type
#+BEGIN_SRC snippet
# name: type TypeName = TypeName;
# key: type
# --
type ${1:TypeName} = ${2:TypeName};
#+END_SRC
**** union
#+BEGIN_SRC snippet
# name: union Type { ... }
# key: union
# --
union ${1:Type} {
     $0
}
#+END_SRC
**** warn
#+BEGIN_SRC snippet
# name: #[warn(lint)]
# key: warn
# --
#[warn(${1:lint})]
#+END_SRC
**** warn!
#+BEGIN_SRC snippet
# name: #![warn(lint)]
# key: warn!
# --
#![warn(${1:lint})]
#+END_SRC
**** while
#+BEGIN_SRC snippet
# name: while expression { ... }
# key: while
# --
while ${1:expression} {
      $0
}
#+END_SRC
**** whilel
#+BEGIN_SRC snippet
# name: while let pattern = expression { ... }
# key: whilel
# --
while let ${1:pattern} = ${2:expression} {
      $0
}
#+END_SRC
*** rustic-mode/
**** .yas-parents
#+BEGIN_SRC snippet
rust-mode
#+END_SRC
*** snippet-mode/
**** cont
#+BEGIN_SRC snippet
# name: cont
# key: cont
# --
# contributor: `user-full-name`
#+END_SRC
**** elisp
#+BEGIN_SRC snippet
# name: elisp
# key: `
# --
\`$0\`
#+END_SRC
**** field
#+BEGIN_SRC snippet
# name: ${ ...  } field
# contributor : joaotavora
# key: $f
# key: field
# --
\${${1:${2:n}:}$3${4:\$(${5:lisp-fn})}\}$0
#+END_SRC
**** group
#+BEGIN_SRC snippet
# name: group
# key: group
# --
# group : ${1:group}
#+END_SRC
**** mirror
#+BEGIN_SRC snippet
# name: ${n:$(...)} mirror
# key: $m
# contributor : joaotavora
# key: mirror
# --
\${${2:n}:${4:\$(${5:reflection-fn})}\}$0
#+END_SRC
**** vars
#+BEGIN_SRC snippet
# name: Snippet header
# contributor : joaotavora
# key: vars
# --
# name: $1${2:
# key: ${3:trigger-key}}${4:
# keybinding : ${5:keybinding}}${6:
# expand-env : (${7:})}
# contributor : $6
# key: vars
# --
$0
#+END_SRC
*** sql-mode/
**** column
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: , ColumnName ColumnType NOT NULL...
# --
	,	${1:Name}		${2:Type}			${3:NOT NULL}
#+END_SRC
**** constraint
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: CONSTRAINT [..] PRIMARY KEY ...
# --
CONSTRAINT [${1:PK_Name}] PRIMARY KEY ${2:CLUSTERED} ([${3:ColumnName}])
#+END_SRC
**** constraint.1
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: CONSTRAINT [..] FOREIGN KEY ...
# --
CONSTRAINT [${1:FK_Name}] FOREIGN KEY ${2:CLUSTERED} ([${3:ColumnName}])
#+END_SRC
**** create
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: create table ...
# --
CREATE TABLE [${1:dbo}].[${2:TableName}]
(
		${3:Id}		${4:INT IDENTITY(1,1)}		${5:NOT NULL}
$0
	CONSTRAINT [${6:PK_}] PRIMARY KEY ${7:CLUSTERED} ([$3])
)
GO
#+END_SRC
**** create.1
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: create procedure ...
# --
CREATE PROCEDURE [${1:dbo}].[${2:Name}]
(
		$3		$4		= ${5:NULL}		${6:OUTPUT}
)
AS
BEGIN
$0
END
GO
#+END_SRC
**** insert
#+BEGIN_SRC snippet
# name: insert
# key: ins
# --
INSERT INTO ${table-name} (${col1, col2}) VALUES (${'val1', 'val2'});$0
#+END_SRC
**** references
#+BEGIN_SRC snippet
# contributor : Alejandro Espinoza Esparza <aespinoza@structum.com.mx>
# name: REFERENCES ...
# --
REFERENCES ${1:TableName}([${2:ColumnName}])
#+END_SRC
*** terraform-mode/
**** data
#+BEGIN_SRC snippet
# name: data
# key: data
# --
data "${1:type}" "${2:name}" {
  $0
}
#+END_SRC
**** locals
#+BEGIN_SRC snippet
# name: locals
# key: locals
# --
locals {
  {$1:name} = ${2:value}
}
#+END_SRC
**** module
#+BEGIN_SRC snippet
# name: module
# key: mod
# --
module "${1:name}" {
  source = "${2:location}"
  $0
}
#+END_SRC
**** output
#+BEGIN_SRC snippet
# name: output
# key: output
# --
output "${1:name}" {
  value = ${2:value}
}
#+END_SRC
**** provider
#+BEGIN_SRC snippet
# name: provider
# key: prov
# --
provider "${1:name}" {
  $0
}
#+END_SRC
**** resource
#+BEGIN_SRC snippet
# name: resource
# key: res
# --
resource "${1:type}" "${2:name}" {
         $0
}
#+END_SRC
**** terraform
#+BEGIN_SRC snippet
# name: terraform
# key: tf
# --
terraform {
  backend "${1:backend}" {
    $0
  }
}
#+END_SRC
**** variable
#+BEGIN_SRC snippet
# name: variable
# key: var
# --
variable "${1:name}" {
  ${2:default = "$3"}
}
#+END_SRC
*** text-mode/
**** .yas-parents
#+BEGIN_SRC snippet
fundamental-mode
#+END_SRC
*** typescript-mode/
**** .yas-parents
#+BEGIN_SRC snippet
js-mode
#+END_SRC
*** yaml-mode/
**** entry
#+BEGIN_SRC snippet
# name: entry
# key: entry
# --
${1:entry}: ${2:value}
$0
#+END_SRC
**** list
#+BEGIN_SRC snippet
# name: list
# key: list
# --
[$1]
$0
#+END_SRC
**** section
#+BEGIN_SRC snippet
# name: section
# key: --
# --
--- # ${1:section}
$0
#+END_SRC
